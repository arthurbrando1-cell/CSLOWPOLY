<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hollow Knight Web Clone - Multiplayer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0f16;
            color: white;
            font-family: 'Cinzel', serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair; /* Custom cursor feel */
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #0f0f16;
            image-rendering: pixelated;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .health-container {
            display: flex;
            gap: 5px;
        }

        .mask {
            width: 30px;
            height: 35px;
            background: #e0e0e0;
            border: 2px solid #1a1a1a;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
        }
        .mask.broken {
            background: #333;
            border-color: #111;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .soul-container {
            width: 60px;
            height: 60px;
            border: 3px solid #d4d4d4;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }

        .soul-liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #fdfdfd, #a8a8a8);
            transition: height 0.2s;
            opacity: 0.8;
            box-shadow: 0 0 15px white;
        }

        /* Online Status */
        #online-status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 0.8rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #server-id {
            display: none; 
            color: #666; 
            font-size: 0.7rem; 
            margin-right: 5px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #444;
        }
        .status-dot.connected { background: #4caf50; box-shadow: 0 0 8px #4caf50; }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .menu-title {
            font-size: 4rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(to bottom, #fff, #999);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: #ddd;
            padding: 15px 40px;
            margin: 10px;
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            border-color: white;
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Controls Visuals */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 40px;
            background: rgba(0,0,0,0.6);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-top: 20px;
            text-align: left;
        }

        .key-row { 
            display: flex; 
            align-items: center; 
            font-size: 1rem; 
            color: #ccc;
            justify-content: space-between;
        }

        .key-cap { 
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            background: #2a2a2a; 
            border: 1px solid #555; 
            border-bottom: 3px solid #111;
            border-radius: 4px; 
            padding: 4px 10px; 
            margin-left: 8px;
            font-family: sans-serif; 
            font-weight: bold;
            color: #fff; 
            min-width: 20px;
            font-size: 0.9rem;
        }
        
        .mouse-icon {
            width: 24px;
            height: 32px;
            border: 2px solid #888;
            border-radius: 12px;
            position: relative;
            margin-left: 8px;
        }
        .mouse-icon::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: #888;
        }
        .mouse-l { background: linear-gradient(90deg, #555 50%, transparent 50%); }
        .mouse-r { background: linear-gradient(90deg, transparent 50%, #555 50%); }

        .hidden { display: none !important; }
        
        .notification {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border: 1px solid #555;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            color: white;
            font-family: 'Cinzel', serif;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: auto;
            display: none;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 20px;
            backdrop-filter: blur(2px);
        }

        /* Server List Styles */
        .server-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            cursor: default;
            transition: background 0.2s;
        }
        .server-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #444;
        }
        .btn-join-small {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: #ddd;
            padding: 4px 10px;
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-join-small:hover {
            background: #fff;
            color: #000;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <!-- UI Layer -->
    <div id="ui-layer">
        <div id="online-status">
            <span id="server-id">cs-low-poly</span>
            <div id="net-dot" class="status-dot"></div>
            <span id="player-count">Offline</span>
        </div>

        <div id="hud" class="hidden">
            <div class="health-container" id="health-bar"></div>
            <div class="soul-container">
                <div class="soul-liquid" id="soul-meter"></div>
            </div>
        </div>

        <div id="notification" class="notification">Saved Game</div>

        <!-- Start Screen -->
        <div id="start-screen" class="menu-screen">
            <h1 class="menu-title">Vessel's Journey</h1>
            <p style="color: #888; margin-top: -20px; margin-bottom: 30px;">Multiplayer Online</p>
            
            <!-- Room Controls -->
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 400px; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #444; border-radius: 8px;">
                
                <!-- CREATE SECTION -->
                <div style="width: 100%; padding-bottom: 15px; border-bottom: 1px solid #333;">
                    <label style="display: block; color: #fff; font-size: 0.9rem; margin-bottom: 10px; font-weight: bold; text-align: center;">CREATE OR JOIN BY CODE</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="room-code-input" placeholder="Room Name" maxlength="15" 
                            style="flex: 2; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #fff; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center; font-size: 1rem; text-transform: uppercase;">
                        
                        <input type="number" id="capacity-input" value="4" min="2" max="32" placeholder="Max"
                            style="flex: 0.5; background: rgba(0,0,0,0.3); border: 1px solid #555; color: white; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center;">
                        
                        <button class="btn" id="btn-join" style="flex: 1; margin: 0; padding: 0; font-size: 0.8rem; background: #333;">GO</button>
                    </div>
                </div>

                <!-- SERVER LIST SECTION -->
                <div style="width: 100%;">
                    <label style="display: block; color: #aaa; font-size: 0.8rem; margin-bottom: 10px; text-align: left;">BROWSE ACTIVE SERVERS</label>
                    
                    <div id="server-list-container" style="
                        width: 100%; 
                        height: 150px; 
                        background: rgba(0,0,0,0.3); 
                        border: 1px solid #333; 
                        overflow-y: auto; 
                        display: flex; 
                        flex-direction: column; 
                        gap: 2px;
                        padding: 2px;
                    ">
                        <div style="color: #666; font-size: 0.8rem; padding: 10px; text-align: center;">Connecting to Lobby...</div>
                    </div>
                </div>
            </div>

            <button class="btn" id="btn-settings">Settings</button>
            
            <div class="controls-grid">
                <div class="key-row"><span>Movement</span> <div><span class="key-cap">A</span><span class="key-cap">D</span></div></div>
                <div class="key-row"><span>Look / Aim</span> <div><span class="key-cap">W</span><span class="key-cap">S</span></div></div>
                <div class="key-row"><span>Jump</span> <span class="key-cap">SPACE</span></div>
                <div class="key-row"><span>Dash</span> <span class="key-cap">SHIFT</span></div>
                <div class="key-row"><span>Attack</span> <div class="mouse-icon mouse-l"></div></div>
                <div class="key-row"><span>Heal (Hold)</span> <div class="mouse-icon mouse-r"></div></div>
            </div>
        </div>

        <!-- Pause Menu -->
        <div id="pause-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Paused</h2>
            <button class="btn" id="btn-resume">Resume</button>
            <button class="btn" id="btn-save">Bench (Save)</button>
            <button class="btn" id="btn-quit">Quit</button>
        </div>

        <!-- Mobile Controls -->
        <div id="mobile-controls">
            <!-- Dynamically populated if mobile -->
        </div>
    </div>
</div>

<!-- Scripts -->
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, onDisconnect, remove, update, get, child } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // --- FIREBASE CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyAIKPooiHzcB5d8_mRiDMyiam4AYel4lZs",
      authDomain: "cs-low-poly.firebaseapp.com",
      databaseURL: "https://cs-low-poly-default-rtdb.firebaseio.com",
      projectId: "cs-low-poly",
      storageBucket: "cs-low-poly.firebasestorage.app",
      messagingSenderId: "291417778108",
      appId: "1:291417778108:web:881869dd93735c6167edb9"
    };

    // --- NETWORK MANAGER ---
    const Network = {
        app: null,
        db: null,
        auth: null,
        playerId: null,
        playerName: null,
        playerRef: null,
        roomRef: null,
        remotePlayers: {},
        connected: false,
        lastUpdate: 0,
        currentRoom: null,
        
        initApp: async () => {
             if (!Network.app) {
                Network.app = initializeApp(firebaseConfig);
                Network.db = getDatabase(Network.app);
                Network.auth = getAuth(Network.app);
                
                Network.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
                Network.playerName = "Vessel " + Math.floor(Math.random() * 1000);

                // Authenticate Anonymously to fix "Permission Denied"
                try {
                    await signInAnonymously(Network.auth);
                    console.log("Authenticated with Firebase");
                    Network.startServerBrowser();
                } catch (error) {
                    console.error("Auth Error:", error);
                    alert("Authentication Failed: " + error.message);
                }
             }
        },

        startServerBrowser: () => {
            const listRef = ref(Network.db, 'hk_multiplayer/rooms');
            onValue(listRef, (snapshot) => {
                const rooms = snapshot.val() || {};
                const listEl = document.getElementById('server-list-container');
                listEl.innerHTML = ''; // Clear

                if (Object.keys(rooms).length === 0) {
                    listEl.innerHTML = '<div style="color: #666; font-size: 0.8rem; padding: 10px;">No active servers found. Create one above!</div>';
                    return;
                }

                Object.keys(rooms).forEach(roomCode => {
                    const r = rooms[roomCode];
                    const count = r.players ? Object.keys(r.players).length : 0;
                    const max = r.settings ? r.settings.maxPlayers : 4;
                    
                    const el = document.createElement('div');
                    el.className = 'server-item';
                    el.innerHTML = `
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span style="color:white; font-weight:bold;">${roomCode}</span>
                            <span style="color:#888; font-size:0.7rem;">Map: Default</span>
                        </div>
                        <div style="display:flex; align-items:center; gap: 10px;">
                            <span style="color: ${count >= max ? '#d32f2f' : '#4caf50'}">${count}/${max}</span>
                            <button class="btn-join-small">JOIN</button>
                        </div>
                    `;
                    el.querySelector('.btn-join-small').addEventListener('click', () => {
                         Network.attemptJoin(roomCode, max);
                    });
                    listEl.appendChild(el);
                });
            });
        },

        attemptJoin: async (roomCode, capacity) => {
            try {
                if (!Network.auth.currentUser) await Network.initApp();

                const db = Network.db;
                const roomRef = ref(db, `hk_multiplayer/rooms/${roomCode}`);
                
                // Check Room Data
                const snapshot = await get(roomRef);
                const val = snapshot.val() || {};
                const players = val.players || {};
                const settings = val.settings || {};
                
                let maxPlayers = settings.maxPlayers;
                
                // Create room settings if new
                if (!maxPlayers) {
                    maxPlayers = parseInt(capacity) || 4;
                    await set(child(roomRef, 'settings/maxPlayers'), maxPlayers);
                }
                
                // Check Capacity
                const currentCount = Object.keys(players).length;
                if (currentCount >= maxPlayers) {
                    alert(`Room ${roomCode} is full! (${currentCount}/${maxPlayers})`);
                    return;
                }

                Network.connectToRoom(roomCode, maxPlayers);

            } catch (e) {
                console.error("Join Failed", e);
                alert("Network Error: " + e.message);
            }
        },

        connectToRoom: (roomCode, maxPlayers) => {
            try {
                Network.currentRoom = roomCode;
                const roomPath = `hk_multiplayer/rooms/${roomCode}/players`;
                Network.playerRef = ref(Network.db, `${roomPath}/${Network.playerId}`);
                Network.roomRef = ref(Network.db, roomPath);

                onDisconnect(Network.playerRef).remove();

                // Remove player on window close manually for faster cleanup
                window.addEventListener('beforeunload', () => {
                     remove(Network.playerRef);
                });

                onValue(Network.roomRef, (snapshot) => {
                    const data = snapshot.val() || {};
                    delete data[Network.playerId];
                    Network.remotePlayers = data;
                    
                    const count = Object.keys(data).length + 1;
                    document.getElementById('player-count').innerText = `${count}/${maxPlayers} Online`;
                    document.getElementById('net-dot').classList.add('connected');
                    document.getElementById('server-id').innerText = `Room: ${roomCode}`;
                    document.getElementById('server-id').style.display = 'block';
                });

                Network.connected = true;
                console.log(`Joined Room: ${roomCode}`);
                window.Game.startGame();

            } catch (e) {
                console.error("Connection Failed", e);
            }
        },

        sendUpdate: (playerData) => {
            if (!Network.connected || !Network.playerRef) return;
            const now = Date.now();
            if (now - Network.lastUpdate > 50) {
                update(Network.playerRef, {
                    x: Math.round(playerData.x),
                    y: Math.round(playerData.y),
                    f: playerData.facing, 
                    s: playerData.animState, 
                    hp: playerData.health,
                    n: Network.playerName,
                    ts: now
                });
                Network.lastUpdate = now;
            }
        }
    };

    // Export Network to global window so Main Game can access it
    window.Network = Network;

    // Initialize Auth Immediately
    Network.initApp();

    // Start Game Hooks
    document.getElementById('btn-join').addEventListener('click', () => {
        const input = document.getElementById('room-code-input');
        const capInput = document.getElementById('capacity-input');
        const code = input.value.trim().toUpperCase();
        
        if(!code) {
            alert("Please enter a room code to create or join.");
            return;
        }

        const capacity = parseInt(capInput.value) || 4;
        Network.attemptJoin(code, capacity);
    });

    document.getElementById('btn-resume').addEventListener('click', () => window.Game.resumeGame());
    document.getElementById('btn-save').addEventListener('click', () => window.Game.saveGame());
    document.getElementById('btn-quit').addEventListener('click', () => location.reload());
    document.getElementById('btn-settings').addEventListener('click', () => alert("Audio: On\nMusic: On\nMultiplayer: Active"));

</script>

<script>
/**
 * HOLLOW KNIGHT CLONE - MAIN ENGINE
 */

// --- CONSTANTS & CONFIG ---
const GRAVITY = 0.6;
const TERMINAL_VELOCITY = 15;
const FRICTION = 0.8;
const MOVE_SPEED = 6;
const JUMP_FORCE = 12;
const DASH_SPEED = 14;
const DASH_DURATION = 12;
const ATTACK_DURATION = 15;
const INVULNERABILITY_TIME = 60;

const COLORS = {
    bg: '#0f0f16',
    platform: '#1a1a2e',
    platformBorder: '#3d3d5c',
    player: '#f0f0f0',
    otherPlayer: 'rgba(200, 200, 255, 0.4)',
    cloak: '#2c3e50',
    enemy: '#d35400',
    boss: '#c0392b',
    soul: '#ecf0f1',
    hazard: '#7f8c8d'
};

// --- AUDIO SYSTEM (Web Audio API) ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

// FX Bus (Delay/Reverb Simulation)
const masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);

const delayNode = audioCtx.createDelay();
delayNode.delayTime.value = 0.4;
const feedbackNode = audioCtx.createGain();
feedbackNode.gain.value = 0.3;
const delayFilter = audioCtx.createBiquadFilter();
delayFilter.type = "lowpass";
delayFilter.frequency.value = 1000;

masterGain.connect(delayNode);
delayNode.connect(delayFilter);
delayFilter.connect(feedbackNode);
feedbackNode.connect(delayNode);
delayNode.connect(audioCtx.destination);

const SoundManager = {
    masterVol: 0.5,
    
    playTone: (freq, type, duration, vol = 0.1, slide = 0) => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        if (slide !== 0) {
            osc.frequency.exponentialRampToValueAtTime(freq + slide, audioCtx.currentTime + duration);
        }
        
        gain.gain.setValueAtTime(vol * SoundManager.masterVol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        
        osc.connect(masterGain); // Connect to Master/FX Bus
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    
    playMusic: () => {
        if (window.musicInterval) return;
        
        // Atmospheric Scale (D Minor Pentatonicish)
        const notes = [146.83, 174.61, 220.00, 261.63, 293.66, 349.23, 392.00]; 
        let tick = 0;

        window.musicInterval = setInterval(() => {
            if (audioCtx.state === 'suspended') return;
            
            // Deep Drone (Bass)
            if (tick % 8 === 0) {
                SoundManager.playTone(73.42, 'sine', 6.0, 0.08); 
                SoundManager.playTone(110.00, 'triangle', 6.0, 0.03); 
            }
            
            // Random Melodic Droplets
            if (Math.random() > 0.4) {
                const freq = notes[Math.floor(Math.random() * notes.length)];
                SoundManager.playTone(freq, 'sine', 2.5, 0.03);
            }
            
            tick++;
        }, 1500);
    },

    playJump: () => SoundManager.playTone(300, 'sine', 0.2, 0.1, -100),
    playDash: () => SoundManager.playTone(150, 'sawtooth', 0.3, 0.1, -50),
    playAttack: () => SoundManager.playTone(200, 'triangle', 0.1, 0.1, -50),
    playHit: () => SoundManager.playTone(100, 'square', 0.2, 0.2, -50),
    playHeal: () => SoundManager.playTone(400, 'sine', 1.0, 0.1, 50),
    playStep: () => SoundManager.playTone(100, 'triangle', 0.05, 0.02, -50)
};

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    mouse: { x: 0, y: 0, left: false, right: false },
    init: () => {
        window.addEventListener('keydown', e => {
            // Map WASD to Arrow logic for internal engine consistency if needed, or just use codes
            Input.keys[e.code] = true;
        });
        window.addEventListener('keyup', e => Input.keys[e.code] = false);
        
        window.addEventListener('mousedown', e => {
            if (e.button === 0) Input.mouse.left = true;
            if (e.button === 2) Input.mouse.right = true;
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 0) Input.mouse.left = false;
            if (e.button === 2) Input.mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault()); // Block context menu
        
        // Touch controls logic remains for mobile
    },
    // Helper to abstract key bindings
    left: () => Input.keys['KeyA'] || Input.keys['ArrowLeft'],
    right: () => Input.keys['KeyD'] || Input.keys['ArrowRight'],
    up: () => Input.keys['KeyW'] || Input.keys['ArrowUp'],
    down: () => Input.keys['KeyS'] || Input.keys['ArrowDown'],
    jump: () => Input.keys['Space'] || Input.keys['KeyZ'],
    dash: () => Input.keys['ShiftLeft'] || Input.keys['KeyC'],
    attack: () => Input.mouse.left || Input.keys['KeyX'],
    heal: () => Input.mouse.right || Input.keys['KeyF'], // F as backup
    pause: () => Input.keys['Escape']
};

// --- ENTITIES ---
class Entity {
    constructor(x, y, w, h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.markedForDeletion = false;
    }
    
    getBounds() {
        return { left: this.x, right: this.x + this.w, top: this.y, bottom: this.y + this.h };
    }

    checkCollision(other) {
        const a = this.getBounds();
        const b = other.getBounds();
        return (a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top);
    }
}

class Particle extends Entity {
    constructor(x, y, color, vx, vy, life) {
        super(x, y, 4, 4);
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; 
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.globalAlpha = 1.0;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 40);
        this.startPos = {x, y};
        this.health = 5;
        this.maxHealth = 5;
        this.soul = 0;
        this.maxSoul = 100;
        this.facing = 1; 
        
        // State
        this.grounded = false;
        this.dashing = false;
        this.dashTimer = 0;
        this.dashCooldown = 0;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.healing = false;
        this.invulnerable = 0;
        this.dead = false;
        this.recoil = 0;
        
        // Animation
        this.animState = 0; // 0: Idle, 1: Run, 2: Jump, 3: Attack
        this.animTimer = 0;
        this.stretch = {x: 1, y: 1};
    }

    respawn() {
        this.x = this.startPos.x;
        this.y = this.startPos.y;
        this.health = this.maxHealth;
        this.dead = false;
        this.vx = 0;
        this.vy = 0;
        Game.camera.shake = 0;
        Game.sceneTransition();
    }

    takeDamage(amount, srcX) {
        if (this.invulnerable > 0 || this.dead) return;
        this.health -= amount;
        this.invulnerable = INVULNERABILITY_TIME;
        this.recoil = 10;
        this.vx = (this.x < srcX ? -1 : 1) * 8;
        this.vy = -5;
        SoundManager.playHit();
        Game.camera.shake = 10;
        Game.updateHUD();

        if (this.health <= 0) {
            this.dead = true;
            for(let i=0; i<20; i++) {
                Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 'black', (Math.random()-0.5)*10, (Math.random()-0.5)*10, 60));
            }
            setTimeout(() => this.respawn(), 1000);
        }
    }

    addSoul(amount) {
        this.soul = Math.min(this.soul + amount, this.maxSoul);
        Game.updateHUD();
    }

    update(map, enemies) {
        if (this.dead) return;
        this.animTimer++;
        
        // Animation Stretch Reset
        this.stretch.x += (1 - this.stretch.x) * 0.1;
        this.stretch.y += (1 - this.stretch.y) * 0.1;

        // Healing
        if (Input.heal() && this.grounded && this.soul >= 33 && this.health < this.maxHealth) {
            this.healing = true;
            this.vx *= 0.8;
            if (this.animTimer % 10 === 0) {
                 Game.particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, 'white', 0, -1, 20));
            }
            
            if (!this.healTimer) this.healTimer = 60;
            this.healTimer--;
            if (this.healTimer <= 0) {
                this.soul -= 33;
                this.health++;
                this.healTimer = 0;
                this.healing = false;
                SoundManager.playHeal();
                Game.updateHUD();
            }
        } else {
            this.healing = false;
            this.healTimer = 0;
        }

        if (this.recoil > 0) {
            this.recoil--;
        } else if (!this.healing) {
            // Movement
            if (Input.left()) { 
                this.vx -= 1; 
                this.facing = -1; 
                this.animState = 1;
            }
            else if (Input.right()) { 
                this.vx += 1; 
                this.facing = 1; 
                this.animState = 1;
            } else {
                this.animState = 0;
            }
            
            // Friction/Limit
            this.vx *= FRICTION;
            if (Math.abs(this.vx) < 0.1) this.vx = 0;
            if (this.vx > MOVE_SPEED) this.vx = MOVE_SPEED;
            if (this.vx < -MOVE_SPEED) this.vx = -MOVE_SPEED;
        }

        // Jump
        if (Input.jump() && !this.lastJumpKey) {
            if (this.grounded) {
                this.vy = -JUMP_FORCE;
                this.stretch = {x: 0.7, y: 1.3};
                SoundManager.playJump();
                this.grounded = false;
                // Dust
                for(let i=0; i<5; i++) Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h, '#555', (Math.random()-0.5)*5, 0, 20));
            } else if (this.wallSliding) {
                this.vy = -JUMP_FORCE;
                this.vx = this.wallDir * -8;
                SoundManager.playJump();
            }
        }
        this.lastJumpKey = Input.jump();

        // Dash
        if (Input.dash() && !this.dashing && this.dashCooldown <= 0) {
            this.dashing = true;
            this.dashTimer = DASH_DURATION;
            this.dashCooldown = 40;
            this.vy = 0;
            this.vx = this.facing * DASH_SPEED;
            SoundManager.playDash();
            this.stretch = {x: 1.4, y: 0.6};
            Game.particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.5)', 0, 0, 10));
        }

        if (this.dashing) {
            this.dashTimer--;
            this.vy = 0;
            if (this.dashTimer <= 0) {
                this.dashing = false;
                this.vx *= 0.5;
            }
        } else {
            // Gravity
            this.vy += GRAVITY;
            if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;
            if (this.dashCooldown > 0) this.dashCooldown--;
        }

        // Attack
        if (Input.attack() && !this.attacking && this.attackCooldown <= 0) {
            this.attacking = true;
            this.attackTimer = ATTACK_DURATION;
            this.attackCooldown = 25;
            this.animState = 3;
            SoundManager.playAttack();
            
            this.attackDir = {x: 0, y: 0};
            if (Input.up()) this.attackDir.y = -1;
            else if (Input.down() && !this.grounded) this.attackDir.y = 1;
            else this.attackDir.x = this.facing;
        }

        if (this.attacking) {
            this.attackTimer--;
            let range = 50;
            let hitBox = { 
                x: this.x + (this.attackDir.x * 30) - (this.attackDir.x === -1 ? range : 0) + (this.attackDir.x === 0 ? -10 : 0),
                y: this.y + (this.attackDir.y * 30) - (this.attackDir.y === -1 ? range : 0) + (this.attackDir.y === 0 ? 0 : 0),
                w: this.attackDir.x !== 0 ? range : 44,
                h: this.attackDir.y !== 0 ? range : 40
            };
            
            enemies.forEach(e => {
                if (!e.dead && !e.invulnerable && 
                    hitBox.x < e.x + e.w && hitBox.x + hitBox.w > e.x &&
                    hitBox.y < e.y + e.h && hitBox.y + hitBox.h > e.y) {
                    
                    e.takeDamage(1);
                    this.addSoul(11);
                    SoundManager.playHit();
                    
                    if (this.attackDir.y === 1) {
                        this.vy = -JUMP_FORCE * 0.8;
                        this.dashCooldown = 0;
                    } else {
                        this.vx = -this.attackDir.x * 5;
                    }
                    
                    for(let i=0; i<5; i++) Game.particles.push(new Particle(e.x + e.w/2, e.y + e.h/2, '#ffa500', (Math.random()-0.5)*10, (Math.random()-0.5)*10, 15));
                }
            });

            if (this.attackTimer <= 0) this.attacking = false;
        }
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.invulnerable > 0) this.invulnerable--;

        // Map Collisions
        this.handleCollisions(map);

        // Update Position
        this.x += this.vx;
        this.y += this.vy;

        // Death pits
        if (this.y > 2000) this.takeDamage(1, this.x);
        
        // Multiplayer Sync
        if (window.Network) {
            window.Network.sendUpdate(this);
        }
    }

    handleCollisions(map) {
        this.grounded = false;
        this.wallSliding = false;
        
        let testX = this.x + this.vx;
        let testY = this.y + this.vy;
        
        for (let rect of map) {
            // Horizontal Collision
            if (rect.type === 'platform' || rect.type === 'wall') {
                if (testX < rect.x + rect.w && testX + this.w > rect.x &&
                    this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                    
                    if (this.vx > 0) {
                        this.x = rect.x - this.w;
                        this.wallDir = 1;
                    } else if (this.vx < 0) {
                        this.x = rect.x + rect.w;
                        this.wallDir = -1;
                    }
                    this.vx = 0;
                    testX = this.x; 
                    
                    if (!this.grounded && this.vy > 0) {
                        this.wallSliding = true;
                        if (this.vy > 2) this.vy = 2;
                    }
                }
            }

            // Vertical Collision
            if (rect.type === 'platform' || rect.type === 'wall') {
                if (this.x < rect.x + rect.w && this.x + this.w > rect.x &&
                    testY < rect.y + rect.h && testY + this.h > rect.y) {
                    
                    if (this.vy > 0) {
                        this.y = rect.y - this.h;
                        this.grounded = true;
                        this.stretch = {x: 1.2, y: 0.8}; // Land squash
                        this.dashCooldown = 0; 
                    } else if (this.vy < 0) {
                        this.y = rect.y + rect.h;
                    }
                    this.vy = 0;
                    testY = this.y;
                }
            }
            
            // Hazards
            if (rect.type === 'hazard') {
                if (testX < rect.x + rect.w && testX + this.w > rect.x &&
                    testY < rect.y + rect.h && testY + this.h > rect.y) {
                    
                    if (this.attacking && this.attackDir.y === 1 && 
                        this.y + this.h <= rect.y + 10 && this.vy > 0) {
                         this.vy = -JUMP_FORCE * 0.9;
                         this.dashCooldown = 0;
                    } else {
                        this.takeDamage(1, rect.x);
                    }
                }
            }

            // Bench
            if (rect.type === 'bench') {
                if (this.x < rect.x + rect.w && this.x + this.w > rect.x &&
                    this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                     if (Input.up() && this.grounded) {
                         this.health = this.maxHealth;
                         this.startPos = {x: rect.x, y: rect.y - 40};
                         window.Game.saveGame();
                         window.Game.showNotification("Bench Rested & Saved");
                         window.Game.updateHUD();
                     }
                }
            }
        }
    }

    draw(ctx, camX, camY) {
        if (this.dead) return;
        if (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

        ctx.save();
        ctx.translate(this.x + this.w/2 - camX, this.y + this.h/2 - camY);
        ctx.scale(this.facing * this.stretch.x, this.stretch.y);

        // Breathing effect
        const breath = Math.sin(this.animTimer * 0.1) * 1;
        
        // Cloak
        ctx.fillStyle = COLORS.cloak;
        ctx.beginPath();
        ctx.moveTo(-10, -10 + breath);
        ctx.lineTo(10, -10 + breath);
        ctx.lineTo(14, 20);
        ctx.lineTo(0, 15);
        ctx.lineTo(-14, 20);
        ctx.fill();

        // Head (Mask)
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.ellipse(0, -12 + breath, 12, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Horns
        ctx.beginPath();
        ctx.moveTo(-8, -20 + breath);
        ctx.quadraticCurveTo(-12, -38 + breath, -2, -28 + breath);
        ctx.lineTo(-4, -20 + breath);
        ctx.fill();
        
        ctx.beginPath();
        ctx.moveTo(8, -20 + breath);
        ctx.quadraticCurveTo(12, -38 + breath, 2, -28 + breath);
        ctx.lineTo(4, -20 + breath);
        ctx.fill();

        // Eyes
        ctx.fillStyle = 'black';
        ctx.beginPath();
        ctx.ellipse(-4, -12 + breath, 3, 5, 0, 0, Math.PI * 2);
        ctx.ellipse(4, -12 + breath, 3, 5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Nail (Weapon)
        if (this.attacking) {
            ctx.fillStyle = '#eee';
            ctx.strokeStyle = 'rgba(255,255,255,0.7)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            // Swing visual depends on direction
            let rot = 0;
            if (this.attackDir) {
                if (this.attackDir.y === -1) rot = -Math.PI/2;
                else if (this.attackDir.y === 1) rot = Math.PI/2;
            }
            
            ctx.rotate(rot);
            ctx.arc(0, 0, 45, -Math.PI/3, Math.PI/3);
            ctx.stroke();
            
            // Blade
            ctx.fillRect(10, -3, 30, 6);
        }

        ctx.restore();
    }
}

class RemotePlayer {
    constructor(id, data) {
        this.id = id;
        this.x = data.x;
        this.y = data.y;
        this.data = data;
    }
    
    update(data) {
        // Simple lerp for smoothness
        this.x += (data.x - this.x) * 0.2;
        this.y += (data.y - this.y) * 0.2;
        this.data = data;
    }
    
    draw(ctx, camX, camY) {
        // Draw Name
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.font = '10px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(this.data.n || 'Unknown', this.x + 12 - camX, this.y - 15 - camY);

        ctx.save();
        ctx.translate(this.x + 12 - camX, this.y + 20 - camY);
        ctx.scale(this.data.f || 1, 1);
        
        ctx.globalAlpha = 0.5;
        // Ghostly Cloak
        ctx.fillStyle = COLORS.otherPlayer;
        ctx.beginPath();
        ctx.moveTo(-10, -10);
        ctx.lineTo(10, -10);
        ctx.lineTo(14, 20);
        ctx.lineTo(0, 15);
        ctx.lineTo(-14, 20);
        ctx.fill();

        // Ghostly Head
        ctx.fillStyle = '#eef';
        ctx.beginPath();
        ctx.ellipse(0, -12, 12, 14, 0, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
        ctx.globalAlpha = 1.0;
    }
}

class Enemy extends Entity {
    constructor(x, y, type) {
        super(x, y, 30, 30);
        this.type = type;
        this.hp = type === 'boss' ? 50 : 3;
        this.maxHp = this.hp;
        this.dir = -1;
        this.timer = 0;
        this.invulnerable = 0;
        this.dead = false;
        
        if (type === 'boss') {
            this.w = 80;
            this.h = 100;
            this.state = 'idle';
        }
    }

    takeDamage(amount) {
        this.hp -= amount;
        this.invulnerable = 10;
        if (this.hp <= 0) {
            this.dead = true;
            if(this.type === 'boss') {
                 Game.showNotification("BOSS DEFEATED");
            }
        }
    }

    update(player, map) {
        if (this.dead) return;
        if (this.invulnerable > 0) this.invulnerable--;

        if (this.type === 'crawler') {
            this.vx = this.dir * 2;
            this.x += this.vx;
            
            let wallAhead = false;
            let ledgeAhead = true;
            
            for(let rect of map) {
                if (rect.type === 'platform' || rect.type === 'wall') {
                    if (this.x + this.vx < rect.x + rect.w && this.x + this.w + this.vx > rect.x &&
                        this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                        wallAhead = true;
                    }
                    let lookAheadX = this.dir === 1 ? this.x + this.w + 5 : this.x - 5;
                    if (lookAheadX > rect.x && lookAheadX < rect.x + rect.w &&
                        this.y + this.h + 2 > rect.y && this.y + this.h - 2 < rect.y + rect.h) {
                        ledgeAhead = false;
                    }
                }
            }

            if (wallAhead || ledgeAhead) {
                this.dir *= -1;
            }

            if (this.checkCollision(player)) {
                player.takeDamage(1, this.x);
            }
        }
        else if (this.type === 'boss') {
            this.timer++;
            let dist = player.x - this.x;

            if (this.state === 'idle') {
                if (Math.abs(dist) < 400 && this.timer > 60) {
                    this.state = Math.random() > 0.5 ? 'jump' : 'charge';
                    this.timer = 0;
                }
            } else if (this.state === 'jump') {
                if (this.timer === 1) {
                    this.vy = -15;
                    this.vx = (dist > 0 ? 1 : -1) * 8;
                }
                this.vy += GRAVITY;
                this.x += this.vx;
                
                if (this.y > 600 - this.h) {
                    this.y = 600 - this.h;
                    this.state = 'slam';
                    this.timer = 0;
                    SoundManager.playTone(80, 'sawtooth', 0.5, 0.2); // Roar
                    Game.camera.shake = 20;
                }
            } else if (this.state === 'slam') {
                if (this.timer > 30) {
                    this.state = 'idle';
                    this.timer = 0;
                }
            } else if (this.state === 'charge') {
                this.vx = (dist > 0 ? 1 : -1) * 6;
                this.x += this.vx;
                if (this.timer > 60) {
                    this.state = 'idle';
                    this.timer = 0;
                }
            }

            if (this.checkCollision(player)) {
                player.takeDamage(1, this.x);
            }
        }
    }

    draw(ctx, camX, camY) {
        if (this.dead) return;
        if (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) ctx.globalAlpha = 0.5;

        ctx.fillStyle = this.type === 'boss' ? COLORS.boss : COLORS.enemy;
        let drawX = this.x - camX;
        let drawY = this.y - camY;
        
        if (this.type === 'crawler') {
            ctx.beginPath();
            ctx.roundRect(drawX, drawY, this.w, this.h, 5);
            ctx.fill();
            // Spikes on back
            ctx.beginPath();
            ctx.moveTo(drawX + 5, drawY);
            ctx.lineTo(drawX + 10, drawY - 5);
            ctx.lineTo(drawX + 15, drawY);
            ctx.fill();
            
            // Eyes
            ctx.fillStyle = 'orange';
            ctx.fillRect(drawX + (this.dir === 1 ? 20 : 5), drawY + 10, 5, 5);
        } else if (this.type === 'boss') {
            ctx.beginPath();
            ctx.roundRect(drawX, drawY, this.w, this.h, 20);
            ctx.fill();
            ctx.fillStyle = '#555';
            ctx.fillRect(drawX - 5, drawY - 10, this.w + 10, 30);
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(drawX + this.w/2, drawY + 40, 20, 0, Math.PI*2);
            ctx.fill();
        }

        ctx.globalAlpha = 1.0;
    }
}

// --- GAME LOGIC ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    width: 0,
    height: 0,
    camera: { x: 0, y: 0, shake: 0 },
    player: null,
    remoteEntities: {},
    map: [],
    enemies: [],
    particles: [],
    state: 'start', 

    init: () => {
        Game.resize();
        window.addEventListener('resize', Game.resize);
        Input.init();
        
        Game.createLevel();
        Game.player = new Player(100, 300);
        
        Game.loop();
    },

    resize: () => {
        Game.width = window.innerWidth;
        Game.height = window.innerHeight;
        Game.canvas.width = Game.width;
        Game.canvas.height = Game.height;
    },

    createLevel: () => {
        const platforms = [
            // Starting Area
            {x: 0, y: 400, w: 800, h: 50, type: 'platform'},
            {x: 300, y: 300, w: 100, h: 20, type: 'platform'},
            {x: 500, y: 200, w: 100, h: 20, type: 'platform'},
            // Wall Jump Section
            {x: 800, y: 0, w: 50, h: 450, type: 'wall'},
            {x: 850, y: 250, w: 200, h: 20, type: 'platform'},
            {x: 1100, y: 150, w: 100, h: 20, type: 'platform'},
            // Spike Pit
            {x: 1200, y: 500, w: 1000, h: 50, type: 'platform'}, 
            {x: 1400, y: 480, w: 400, h: 20, type: 'hazard'},   
            {x: 1500, y: 350, w: 50, h: 10, type: 'platform'},  
            {x: 1700, y: 300, w: 50, h: 10, type: 'platform'},
            // Boss Arena
            {x: 2300, y: 600, w: 800, h: 50, type: 'platform'}, 
            {x: 2250, y: 200, w: 50, h: 450, type: 'wall'},     
            {x: 3100, y: 200, w: 50, h: 450, type: 'wall'},     
            // Bench Spot
            {x: 50, y: 350, w: 60, h: 50, type: 'bench'}
        ];
        
        Game.map = platforms;

        Game.enemies = [
            new Enemy(400, 370, 'crawler'),
            new Enemy(900, 220, 'crawler'),
            new Enemy(2600, 500, 'boss')
        ];
    },

    update: () => {
        if (Game.state !== 'playing') return;

        if (Input.pause()) {
            Game.togglePause();
            Input.keys['Escape'] = false; 
            return;
        }

        Game.player.update(Game.map, Game.enemies);

        // Update Remote Players
        if (window.Network && window.Network.remotePlayers) {
            Object.keys(window.Network.remotePlayers).forEach(key => {
                if (!Game.remoteEntities[key]) {
                    Game.remoteEntities[key] = new RemotePlayer(key, window.Network.remotePlayers[key]);
                } else {
                    Game.remoteEntities[key].update(window.Network.remotePlayers[key]);
                }
            });
            // Cleanup disconnected
            Object.keys(Game.remoteEntities).forEach(key => {
                if (!window.Network.remotePlayers[key]) delete Game.remoteEntities[key];
            });
        }

        // Camera Follow
        let targetCamX = Game.player.x + Game.player.w/2 - Game.width/2;
        let targetCamY = Game.player.y + Game.player.h/2 - Game.height/2;
        
        Game.camera.x += (targetCamX - Game.camera.x) * 0.1;
        Game.camera.y += (targetCamY - Game.camera.y) * 0.1;

        if (Game.camera.shake > 0) {
            Game.camera.x += (Math.random() - 0.5) * Game.camera.shake;
            Game.camera.y += (Math.random() - 0.5) * Game.camera.shake;
            Game.camera.shake *= 0.9;
            if(Game.camera.shake < 0.5) Game.camera.shake = 0;
        }

        Game.enemies.forEach(e => e.update(Game.player, Game.map));

        Game.particles.forEach(p => p.update());
        Game.particles = Game.particles.filter(p => !p.markedForDeletion);
    },

    draw: () => {
        const ctx = Game.ctx;
        ctx.clearRect(0, 0, Game.width, Game.height);

        // Background
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, Game.width, Game.height);
        
        // Parallax
        ctx.fillStyle = '#050508';
        for(let i=0; i<10; i++) {
            ctx.fillRect((i*300) - (Game.camera.x * 0.2), 0, 100, Game.height);
        }

        let camX = Game.camera.x;
        let camY = Game.camera.y;

        // Map
        Game.map.forEach(rect => {
            if (rect.type === 'hazard') {
                ctx.fillStyle = COLORS.hazard;
                for(let i=rect.x; i<rect.x+rect.w; i+=20) {
                    ctx.beginPath();
                    ctx.moveTo(i - camX, rect.y + rect.h - camY);
                    ctx.lineTo(i + 10 - camX, rect.y - camY);
                    ctx.lineTo(i + 20 - camX, rect.y + rect.h - camY);
                    ctx.fill();
                }
            } else if (rect.type === 'bench') {
                ctx.fillStyle = '#555';
                ctx.fillRect(rect.x - camX, rect.y - camY + 20, rect.w, 30); 
                ctx.fillRect(rect.x - camX + 5, rect.y - camY, 10, 50); 
                ctx.fillRect(rect.x - camX + 45, rect.y - camY, 10, 50);
                
                // Lamp
                ctx.fillStyle = '#ddd';
                ctx.fillRect(rect.x - camX + 65, rect.y - camY - 40, 5, 90);
                ctx.beginPath();
                ctx.arc(rect.x - camX + 67, rect.y - camY - 40, 10, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255, 255, 200, 0.5)';
                ctx.fill();
            } else {
                ctx.fillStyle = COLORS.platform;
                ctx.strokeStyle = COLORS.platformBorder;
                ctx.lineWidth = 2;
                ctx.fillRect(rect.x - camX, rect.y - camY, rect.w, rect.h);
                ctx.strokeRect(rect.x - camX, rect.y - camY, rect.w, rect.h);
                
                // Atmosphere
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(rect.x - camX + 5, rect.y - camY + 5, rect.w - 10, rect.h - 10);
            }
        });

        // Remote Players
        Object.values(Game.remoteEntities).forEach(rp => rp.draw(ctx, camX, camY));

        Game.enemies.forEach(e => e.draw(ctx, camX, camY));
        Game.particles.forEach(p => p.draw(ctx, camX, camY));
        Game.player.draw(ctx, camX, camY);
    },

    loop: () => {
        Game.update();
        Game.draw();
        requestAnimationFrame(Game.loop);
    },

    sceneTransition: () => {
        const overlay = document.createElement('div');
        overlay.style.position = 'absolute';
        overlay.style.top = '0';
        overlay.style.left = '0';
        overlay.style.width = '100%';
        overlay.style.height = '100%';
        overlay.style.background = 'black';
        overlay.style.transition = 'opacity 1s';
        document.body.appendChild(overlay);
        
        setTimeout(() => overlay.style.opacity = '0', 100);
        setTimeout(() => overlay.remove(), 1100);
    },

    updateHUD: () => {
        const bar = document.getElementById('health-bar');
        bar.innerHTML = '';
        for(let i=0; i<Game.player.maxHealth; i++) {
            const mask = document.createElement('div');
            mask.className = 'mask' + (i >= Game.player.health ? ' broken' : '');
            bar.appendChild(mask);
        }
        const soulPct = (Game.player.soul / Game.player.maxSoul) * 100;
        document.getElementById('soul-meter').style.height = soulPct + '%';
    },

    showNotification: (text) => {
        const n = document.getElementById('notification');
        n.innerText = text;
        n.style.opacity = 1;
        setTimeout(() => n.style.opacity = 0, 2000);
    },

    saveGame: () => {
        if (!Game.player) return;
        const data = {
            player: {
                x: Game.player.x,
                y: Game.player.y,
                health: Game.player.health,
                soul: Game.player.soul,
                startPos: Game.player.startPos
            },
            bossDead: Game.enemies.find(e => e.type === 'boss').dead
        };
        localStorage.setItem('hk_save', JSON.stringify(data));
        Game.showNotification("Game Saved");
    },

    loadGame: () => {
        const raw = localStorage.getItem('hk_save');
        if (!raw) return;
        const data = JSON.parse(raw);
        Game.startGame();
        Game.player.x = data.player.x;
        Game.player.y = data.player.y;
        Game.player.startPos = data.player.startPos;
        Game.player.health = data.player.health;
        Game.player.soul = data.player.soul;
        if (data.bossDead) {
            const boss = Game.enemies.find(e => e.type === 'boss');
            if (boss) boss.dead = true;
        }
        Game.updateHUD();
    },

    startGame: () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        
        Game.player.respawn();
        Game.state = 'playing';
        Game.updateHUD();
        SoundManager.playMusic();
        
        // Mobile Controls
        if (/Android|iPhone/i.test(navigator.userAgent)) {
            document.getElementById('mobile-controls').style.display = 'flex';
        }
    },

    togglePause: () => {
        const menu = document.getElementById('pause-menu');
        if (Game.state === 'playing') {
            Game.state = 'paused';
            menu.classList.remove('hidden');
        } else if (Game.state === 'paused') {
            Game.resumeGame();
        }
    },

    resumeGame: () => {
        Game.state = 'playing';
        document.getElementById('pause-menu').classList.add('hidden');
    }
};

// Expose Game to Global Window
window.Game = Game;

// Start Engine
window.onload = Game.init;

</script>
</body>
</html>
