<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hollow Knight Web Clone - Multiplayer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0f16;
            color: white;
            font-family: 'Cinzel', serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #0f0f16;
            image-rendering: pixelated;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .health-container {
            display: flex;
            gap: 5px;
        }

        .mask {
            width: 30px;
            height: 35px;
            background: #e0e0e0;
            border: 2px solid #1a1a1a;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
        }
        .mask.broken {
            background: #333;
            border-color: #111;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .soul-container {
            width: 60px;
            height: 60px;
            border: 3px solid #d4d4d4;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }

        .soul-liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #fdfdfd, #a8a8a8);
            transition: height 0.2s;
            opacity: 0.8;
            box-shadow: 0 0 15px white;
        }

        /* Online Status */
        #online-status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 0.8rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #server-id {
            display: none; 
            color: #666; 
            font-size: 0.7rem; 
            margin-right: 5px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #444;
        }
        .status-dot.connected { background: #4caf50; box-shadow: 0 0 8px #4caf50; }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .menu-title {
            font-size: 4rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(to bottom, #fff, #999);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: #ddd;
            padding: 15px 40px;
            margin: 10px;
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            border-color: white;
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Controls Visuals */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 40px;
            background: rgba(0,0,0,0.6);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-top: 20px;
            text-align: left;
        }

        .key-row { 
            display: flex; 
            align-items: center; 
            font-size: 1rem; 
            color: #ccc;
            justify-content: space-between;
        }

        .key-cap { 
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            background: #2a2a2a; 
            border: 1px solid #555; 
            border-bottom: 3px solid #111;
            border-radius: 4px; 
            padding: 4px 10px; 
            margin-left: 8px;
            font-family: sans-serif; 
            font-weight: bold;
            color: #fff; 
            min-width: 20px;
            font-size: 0.9rem;
        }
        
        .mouse-icon {
            width: 24px;
            height: 32px;
            border: 2px solid #888;
            border-radius: 12px;
            position: relative;
            margin-left: 8px;
        }
        .mouse-icon::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: #888;
        }
        .mouse-l { background: linear-gradient(90deg, #555 50%, transparent 50%); }
        .mouse-r { background: linear-gradient(90deg, transparent 50%, #555 50%); }

        .hidden { display: none !important; }
        
        .notification {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border: 1px solid #555;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            color: white;
            font-family: 'Cinzel', serif;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            width: 100%;
            height: 150px;
            pointer-events: auto;
            display: none;
            justify-content: space-between;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .touch-btn {
            position: absolute;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: rgba(255, 255, 255, 0.7);
            font-size: 20px;
            backdrop-filter: blur(2px);
        }

        /* Server List Styles */
        .server-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            cursor: default;
            transition: background 0.2s;
        }
        .server-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #444;
        }
        .btn-join-small {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: #ddd;
            padding: 4px 10px;
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-join-small:hover {
            background: #fff;
            color: #000;
        }

        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #ffffff;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #444;
            border-radius: 2px;
        }
        input[type=range]:focus {
            outline: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="online-status">
            <span id="server-id">cs-low-poly</span>
            <div id="net-dot" class="status-dot"></div>
            <span id="player-count">Offline</span>
        </div>

        <div id="hud" class="hidden">
            <div class="health-container" id="health-bar"></div>
            <div class="soul-container">
                <div class="soul-liquid" id="soul-meter"></div>
            </div>
        </div>

        <div id="notification" class="notification">Saved Game</div>

        <div id="start-screen" class="menu-screen">
            <h1 class="menu-title">Vessel's Journey</h1>
            <p style="color: #888; margin-top: -20px; margin-bottom: 30px;">Multiplayer Online</p>
            
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 400px; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #444; border-radius: 8px;">
                
                <div style="width: 100%; padding-bottom: 15px; border-bottom: 1px solid #333;">
                    <label style="display: block; color: #fff; font-size: 0.9rem; margin-bottom: 10px; font-weight: bold; text-align: center;">CREATE OR JOIN BY CODE</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="room-code-input" placeholder="Room Name" maxlength="15" 
                            style="flex: 2; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #fff; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center; font-size: 1rem; text-transform: uppercase;">
                        
                        <input type="number" id="capacity-input" value="4" min="2" max="32" placeholder="Max"
                            style="flex: 0.5; background: rgba(0,0,0,0.3); border: 1px solid #555; color: white; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center;">
                        
                        <button class="btn" id="btn-join" style="flex: 1; margin: 0; padding: 0; font-size: 0.8rem; background: #333;">GO</button>
                    </div>
                </div>

                <div style="width: 100%;">
                    <label style="display: block; color: #aaa; font-size: 0.8rem; margin-bottom: 10px; text-align: left;">BROWSE ACTIVE SERVERS</label>
                    
                    <div id="server-list-container" style="
                        width: 100%; 
                        height: 150px; 
                        background: rgba(0,0,0,0.3); 
                        border: 1px solid #333; 
                        overflow-y: auto; 
                        display: flex; 
                        flex-direction: column; 
                        gap: 2px;
                        padding: 2px;
                    ">
                        <div style="color: #666; font-size: 0.8rem; padding: 10px; text-align: center;">Connecting to Lobby...</div>
                    </div>
                </div>
            </div>

            <button class="btn" id="btn-settings">Settings</button>
            
            <div class="controls-grid">
                <div class="key-row"><span>Movement</span> <div><span class="key-cap">A</span><span class="key-cap">D</span></div></div>
                <div class="key-row"><span>Look / Aim</span> <div><span class="key-cap">W</span><span class="key-cap">S</span></div></div>
                <div class="key-row"><span>Jump</span> <span class="key-cap">SPACE</span></div>
                <div class="key-row"><span>Dash</span> <span class="key-cap">SHIFT</span></div>
                <div class="key-row"><span>Attack</span> <div class="mouse-icon mouse-l"></div></div>
                <div class="key-row"><span>Heal (Hold)</span> <div class="mouse-icon mouse-r"></div></div>
            </div>
        </div>

        <!-- NEW SETTINGS MENU -->
        <div id="settings-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Settings</h2>
            
            <div style="width: 300px; display: flex; flex-direction: column; gap: 20px; background: rgba(0,0,0,0.6); padding: 30px; border-radius: 8px; border: 1px solid #444;">
                <div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <label>Master Volume</label>
                        <span id="val-master" style="color: #aaa;">50%</span>
                    </div>
                    <input type="range" id="vol-master" min="0" max="100" value="50" style="width: 100%;">
                </div>
                <div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <label>Music Volume</label>
                        <span id="val-music" style="color: #aaa;">10%</span>
                    </div>
                    <input type="range" id="vol-music" min="0" max="100" value="10" style="width: 100%;">
                </div>
                <div>
                    <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                        <label>SFX Volume</label>
                        <span id="val-sfx" style="color: #aaa;">50%</span>
                    </div>
                    <input type="range" id="vol-sfx" min="0" max="100" value="50" style="width: 100%;">
                </div>
            </div>

            <button class="btn" id="btn-settings-back" style="margin-top: 30px;">Back</button>
        </div>

        <div id="pause-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Paused</h2>
            <button class="btn" id="btn-resume">Resume</button>
            <button class="btn" id="btn-save">Bench (Save)</button>
            <button class="btn" id="btn-quit">Quit</button>
        </div>

        <div id="mobile-controls">
            </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, onDisconnect, remove, update, get, child } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // --- FIREBASE CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyAIKPooiHzcB5d8_mRiDMyiam4AYel4lZs",
      authDomain: "cs-low-poly.firebaseapp.com",
      databaseURL: "https://cs-low-poly-default-rtdb.firebaseio.com",
      projectId: "cs-low-poly",
      storageBucket: "cs-low-poly.firebasestorage.app",
      messagingSenderId: "291417778108",
      appId: "1:291417778108:web:881869dd93735c6167edb9"
    };

    // --- NETWORK MANAGER ---
    const Network = {
        app: null,
        db: null,
        auth: null,
        playerId: null,
        playerName: null,
        playerRef: null,
        roomRef: null,
        remotePlayers: {},
        connected: false,
        lastUpdate: 0,
        currentRoom: null,
        
        initApp: async () => {
             if (!Network.app) {
                Network.app = initializeApp(firebaseConfig);
                Network.db = getDatabase(Network.app);
                Network.auth = getAuth(Network.app);
                
                Network.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
                Network.playerName = "Vessel " + Math.floor(Math.random() * 1000);
             }

             // Ensure authentication is complete
             if (!Network.auth.currentUser) {
                try {
                    await signInAnonymously(Network.auth);
                    console.log("Authenticated with Firebase");
                    Network.startServerBrowser();
                } catch (error) {
                    console.error("Auth Error:", error);
                    alert("Authentication Failed: " + error.message);
                }
             }
        },

        startServerBrowser: () => {
            const listRef = ref(Network.db, 'hk_multiplayer/rooms');
            onValue(listRef, (snapshot) => {
                const rooms = snapshot.val() || {};
                const listEl = document.getElementById('server-list-container');
                listEl.innerHTML = ''; // Clear

                if (Object.keys(rooms).length === 0) {
                    listEl.innerHTML = '<div style="color: #666; font-size: 0.8rem; padding: 10px;">No active servers found. Create one above!</div>';
                    return;
                }

                Object.keys(rooms).forEach(roomCode => {
                    const r = rooms[roomCode];
                    const count = r.players ? Object.keys(r.players).length : 0;
                    const max = r.settings ? r.settings.maxPlayers : 4;
                    
                    const el = document.createElement('div');
                    el.className = 'server-item';
                    el.innerHTML = `
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span style="color:white; font-weight:bold;">${roomCode}</span>
                            <span style="color:#888; font-size:0.7rem;">Map: Default</span>
                        </div>
                        <div style="display:flex; align-items:center; gap: 10px;">
                            <span style="color: ${count >= max ? '#d32f2f' : '#4caf50'}">${count}/${max}</span>
                            <button class="btn-join-small">JOIN</button>
                        </div>
                    `;
                    el.querySelector('.btn-join-small').addEventListener('click', () => {
                         Network.attemptJoin(roomCode, max);
                    });
                    listEl.appendChild(el);
                });
            });
        },

        attemptJoin: async (roomCode, capacity) => {
            try {
                await Network.initApp(); // Ensure Auth

                const db = Network.db;
                const roomRef = ref(db, `hk_multiplayer/rooms/${roomCode}`);
                
                const snapshot = await get(roomRef);
                const val = snapshot.val() || {};
                const players = val.players || {};
                const settings = val.settings || {};
                
                let maxPlayers = settings.maxPlayers;
                
                if (!maxPlayers) {
                    maxPlayers = parseInt(capacity) || 4;
                    await set(child(roomRef, 'settings/maxPlayers'), maxPlayers);
                }
                
                const currentCount = Object.keys(players).length;
                if (currentCount >= maxPlayers) {
                    alert(`Room ${roomCode} is full! (${currentCount}/${maxPlayers})`);
                    return;
                }

                Network.connectToRoom(roomCode, maxPlayers);

            } catch (e) {
                console.error("Join Failed", e);
                alert("Network Error: " + e.message);
            }
        },

        connectToRoom: (roomCode, maxPlayers) => {
            try {
                Network.currentRoom = roomCode;
                const roomPath = `hk_multiplayer/rooms/${roomCode}/players`;
                Network.playerRef = ref(Network.db, `${roomPath}/${Network.playerId}`);
                Network.roomRef = ref(Network.db, roomPath);

                onDisconnect(Network.playerRef).remove();

                window.addEventListener('beforeunload', () => {
                      remove(Network.playerRef);
                });

                onValue(Network.roomRef, (snapshot) => {
                    const data = snapshot.val() || {};
                    delete data[Network.playerId];
                    Network.remotePlayers = data;
                    
                    const count = Object.keys(data).length + 1;
                    document.getElementById('player-count').innerText = `${count}/${maxPlayers} Online`;
                    document.getElementById('net-dot').classList.add('connected');
                    document.getElementById('server-id').innerText = `Room: ${roomCode}`;
                    document.getElementById('server-id').style.display = 'block';
                });

                Network.connected = true;
                console.log(`Joined Room: ${roomCode}`);
                window.Game.startGame();

            } catch (e) {
                console.error("Connection Failed", e);
            }
        },

        sendUpdate: (playerData) => {
            if (!Network.connected || !Network.playerRef) return;
            const now = Date.now();
            if (now - Network.lastUpdate > 50) {
                update(Network.playerRef, {
                    x: Math.round(playerData.x),
                    y: Math.round(playerData.y),
                    f: playerData.facing, 
                    a: playerData.attacking, // Send attack state
                    hp: playerData.health,
                    n: Network.playerName,
                    ts: now
                });
                Network.lastUpdate = now;
            }
        }
    };

    window.Network = Network;

    Network.initApp();

    document.getElementById('btn-join').addEventListener('click', () => {
        const input = document.getElementById('room-code-input');
        const capInput = document.getElementById('capacity-input');
        const code = input.value.trim().toUpperCase();
        
        if(!code) {
            alert("Please enter a room code to create or join.");
            return;
        }

        const capacity = parseInt(capInput.value) || 4;
        Network.attemptJoin(code, capacity);
    });

    // Settings & Menus
    document.getElementById('btn-resume').addEventListener('click', () => window.Game.resumeGame());
    document.getElementById('btn-save').addEventListener('click', () => window.Game.saveGame());
    document.getElementById('btn-quit').addEventListener('click', () => location.reload());
    
    // Open Settings
    document.getElementById('btn-settings').addEventListener('click', () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('settings-menu').classList.remove('hidden');
    });

    // Back from Settings
    document.getElementById('btn-settings-back').addEventListener('click', () => {
        document.getElementById('settings-menu').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    });

    // Volume Sliders
    const updateVolLabel = (id, val) => document.getElementById(id).innerText = Math.round(val * 100) + '%';
    
    document.getElementById('vol-master').addEventListener('input', (e) => {
        const val = e.target.value / 100;
        window.SoundManager.setMaster(val);
        updateVolLabel('val-master', val);
    });

    document.getElementById('vol-music').addEventListener('input', (e) => {
        const val = e.target.value / 100;
        window.SoundManager.setMusic(val);
        updateVolLabel('val-music', val);
    });

    document.getElementById('vol-sfx').addEventListener('input', (e) => {
        const val = e.target.value / 100;
        window.SoundManager.setSfx(val);
        updateVolLabel('val-sfx', val);
    });

</script>

<script>
/**
 * HOLLOW KNIGHT CLONE - MAIN ENGINE
 */

const GRAVITY = 0.6;
const TERMINAL_VELOCITY = 15;
const FRICTION = 0.8;
const MOVE_SPEED = 6;
const JUMP_FORCE = 12;
const DASH_SPEED = 14;
const DASH_DURATION = 12;
const ATTACK_DURATION = 15;
const INVULNERABILITY_TIME = 60;

const COLORS = {
    bg: '#0f0f16',
    platform: '#1a1a2e',
    platformBorder: '#3d3d5c',
    player: '#f0f0f0',
    otherPlayer: '#d0d0f0', // Slight tint for others
    cloak: '#2c3e50',
    enemy: '#d35400',
    boss: '#c0392b',
    soul: '#ecf0f1',
    hazard: '#7f8c8d'
};

// --- AUDIO SYSTEM ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

const masterGain = audioCtx.createGain();
masterGain.connect(audioCtx.destination);

const delayNode = audioCtx.createDelay();
delayNode.delayTime.value = 0.4;
const feedbackNode = audioCtx.createGain();
feedbackNode.gain.value = 0.3;
const delayFilter = audioCtx.createBiquadFilter();
delayFilter.type = "lowpass";
delayFilter.frequency.value = 1000;

masterGain.connect(delayNode);
delayNode.connect(delayFilter);
delayFilter.connect(feedbackNode);
feedbackNode.connect(delayNode);
delayNode.connect(audioCtx.destination);

const SoundManager = {
    masterVol: 0.5,
    musicVol: 0.1, // Lower default music volume
    sfxVol: 0.5,

    setMaster: (v) => SoundManager.masterVol = v,
    setMusic: (v) => SoundManager.musicVol = v,
    setSfx: (v) => SoundManager.sfxVol = v,
    
    playTone: (freq, type, duration, vol = 0.1, slide = 0, isMusic = false) => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        if (slide !== 0) {
            osc.frequency.exponentialRampToValueAtTime(freq + slide, audioCtx.currentTime + duration);
        }
        
        // Calculate volume based on category
        const catVol = isMusic ? SoundManager.musicVol : SoundManager.sfxVol;
        const finalVol = vol * SoundManager.masterVol * catVol;

        gain.gain.setValueAtTime(finalVol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        
        osc.connect(masterGain); 
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
    },
    
    playMusic: () => {
        if (window.musicInterval) return;
        const notes = [146.83, 174.61, 220.00, 261.63, 293.66, 349.23, 392.00]; 
        let tick = 0;

        window.musicInterval = setInterval(() => {
            if (audioCtx.state === 'suspended') return;
            
            // Bass
            if (tick % 8 === 0) {
                SoundManager.playTone(73.42, 'sine', 6.0, 0.08, 0, true); 
                SoundManager.playTone(110.00, 'triangle', 6.0, 0.03, 0, true); 
            }
            
            // Melody
            if (Math.random() > 0.4) {
                const freq = notes[Math.floor(Math.random() * notes.length)];
                SoundManager.playTone(freq, 'sine', 2.5, 0.03, 0, true);
            }
            
            tick++;
        }, 1500);
    },

    playJump: () => SoundManager.playTone(300, 'sine', 0.2, 0.1, -100),
    playDash: () => SoundManager.playTone(150, 'sawtooth', 0.3, 0.1, -50),
    playAttack: () => SoundManager.playTone(200, 'triangle', 0.1, 0.1, -50),
    playHit: () => SoundManager.playTone(100, 'square', 0.2, 0.2, -50),
    playHeal: () => SoundManager.playTone(400, 'sine', 1.0, 0.1, 50),
    playStep: () => SoundManager.playTone(100, 'triangle', 0.05, 0.02, -50)
};
window.SoundManager = SoundManager;

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    mouse: { x: 0, y: 0, left: false, right: false },
    init: () => {
        window.addEventListener('keydown', e => Input.keys[e.code] = true);
        window.addEventListener('keyup', e => Input.keys[e.code] = false);
        window.addEventListener('mousedown', e => {
            if (e.button === 0) Input.mouse.left = true;
            if (e.button === 2) Input.mouse.right = true;
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 0) Input.mouse.left = false;
            if (e.button === 2) Input.mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
    },
    left: () => Input.keys['KeyA'] || Input.keys['ArrowLeft'],
    right: () => Input.keys['KeyD'] || Input.keys['ArrowRight'],
    up: () => Input.keys['KeyW'] || Input.keys['ArrowUp'],
    down: () => Input.keys['KeyS'] || Input.keys['ArrowDown'],
    jump: () => Input.keys['Space'] || Input.keys['KeyZ'],
    dash: () => Input.keys['ShiftLeft'] || Input.keys['KeyC'],
    attack: () => Input.mouse.left || Input.keys['KeyX'],
    heal: () => Input.mouse.right || Input.keys['KeyF'], 
    pause: () => Input.keys['Escape']
};

// --- ENTITIES ---
class Entity {
    constructor(x, y, w, h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.markedForDeletion = false;
    }
    
    getBounds() {
        return { left: this.x, right: this.x + this.w, top: this.y, bottom: this.y + this.h };
    }

    checkCollision(other) {
        const a = this.getBounds();
        const b = other.getBounds();
        return (a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top);
    }
}

class Particle extends Entity {
    constructor(x, y, color, vx, vy, life) {
        super(x, y, 4, 4);
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; 
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.globalAlpha = 1.0;
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 40);
        this.startPos = {x, y};
        this.health = 5;
        this.maxHealth = 5;
        this.soul = 0;
        this.maxSoul = 100;
        this.facing = 1; 
        
        // State
        this.grounded = false;
        this.dashing = false;
        this.dashTimer = 0;
        this.dashCooldown = 0;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.healing = false;
        this.invulnerable = 0;
        this.dead = false;
        this.recoil = 0;
        
        // Animation
        this.animState = 0; 
        this.animTimer = 0;
        this.stretch = {x: 1, y: 1};
    }

    respawn() {
        this.x = this.startPos.x;
        this.y = this.startPos.y;
        this.health = this.maxHealth;
        this.dead = false;
        this.vx = 0;
        this.vy = 0;
        Game.camera.shake = 0;
        Game.sceneTransition();
    }

    takeDamage(amount, srcX) {
        if (this.invulnerable > 0 || this.dead) return;
        this.health -= amount;
        this.invulnerable = INVULNERABILITY_TIME;
        this.recoil = 10;
        this.vx = (this.x < srcX ? -1 : 1) * 8;
        this.vy = -5;
        SoundManager.playHit();
        Game.camera.shake = 10;
        Game.updateHUD();

        if (this.health <= 0) {
            this.dead = true;
            for(let i=0; i<20; i++) {
                Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 'black', (Math.random()-0.5)*10, (Math.random()-0.5)*10, 60));
            }
            setTimeout(() => this.respawn(), 1000);
        }
    }

    addSoul(amount) {
        this.soul = Math.min(this.soul + amount, this.maxSoul);
        Game.updateHUD();
    }

    update(map, enemies) {
        if (this.dead) return;
        this.animTimer++;
        
        this.stretch.x += (1 - this.stretch.x) * 0.1;
        this.stretch.y += (1 - this.stretch.y) * 0.1;

        if (Input.heal() && this.grounded && this.soul >= 33 && this.health < this.maxHealth) {
            this.healing = true;
            this.vx *= 0.8;
            if (this.animTimer % 10 === 0) {
                 Game.particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, 'white', 0, -1, 20));
            }
            
            if (!this.healTimer) this.healTimer = 60;
            this.healTimer--;
            if (this.healTimer <= 0) {
                this.soul -= 33;
                this.health++;
                this.healTimer = 0;
                this.healing = false;
                SoundManager.playHeal();
                Game.updateHUD();
            }
        } else {
            this.healing = false;
            this.healTimer = 0;
        }

        if (this.recoil > 0) {
            this.recoil--;
        } else if (!this.healing) {
            if (Input.left()) { 
                this.vx -= 1; 
                this.facing = -1; 
                this.animState = 1;
            }
            else if (Input.right()) { 
                this.vx += 1; 
                this.facing = 1; 
                this.animState = 1;
            } else {
                this.animState = 0;
            }
            
            this.vx *= FRICTION;
            if (Math.abs(this.vx) < 0.1) this.vx = 0;
            if (this.vx > MOVE_SPEED) this.vx = MOVE_SPEED;
            if (this.vx < -MOVE_SPEED) this.vx = -MOVE_SPEED;
        }

        if (Input.jump() && !this.lastJumpKey) {
            if (this.grounded) {
                this.vy = -JUMP_FORCE;
                this.stretch = {x: 0.7, y: 1.3};
                this.grounded = false;
                SoundManager.playJump();
                this.lastJumpKey = true;
                this.animState = 2;
                
                for(let i=0; i<5; i++) {
                    Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h, 'white', (Math.random()-0.5)*4, Math.random()*-2, 20));
                }
            }
        } else if (!Input.jump()) {
            this.lastJumpKey = false;
            if (this.vy < -3) this.vy *= 0.5;
        }

        if (Input.dash() && !this.dashing && this.dashCooldown <= 0 && !this.healing) {
            this.dashing = true;
            this.dashTimer = DASH_DURATION;
            this.dashCooldown = 40; 
            this.vx = this.facing * DASH_SPEED;
            this.vy = 0;
            SoundManager.playDash();
            Game.camera.shake = 5;
        }

        if (Input.attack() && !this.attacking && this.attackCooldown <= 0 && !this.healing) {
            this.attacking = true;
            this.attackTimer = ATTACK_DURATION;
            this.attackCooldown = 25;
            SoundManager.playAttack();
            
            const reach = 40;
            const hitX = this.facing === 1 ? this.x + this.w : this.x - reach;
            const hitY = this.y + 10;
            
            enemies.forEach(e => {
                if (!e.dead && hitX < e.x + e.w && hitX + reach > e.x && hitY < e.y + e.h && hitY + 20 > e.y) {
                    e.takeDamage(1);
                    this.addSoul(15);
                    this.recoil = 5;
                    if(this.grounded) this.vx = -this.facing * 5;
                }
            });
        }

        if (this.dashing) {
            this.dashTimer--;
            this.vy = 0;
            if (this.dashTimer <= 0) {
                this.dashing = false;
                this.vx *= 0.2;
            }
            if (this.dashTimer % 3 === 0) {
                Game.particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.5)', 0, 0, 10));
            }
        } else {
            this.vy += GRAVITY;
            if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;
        }

        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
        if (this.attacking) this.attackTimer--;
        if (this.attackTimer <= 0) this.attacking = false;

        this.x += this.vx;
        this.checkCollisions(map, 'x');
        this.y += this.vy;
        this.checkCollisions(map, 'y');
        
        if (this.y > 2000) this.takeDamage(1, this.x + 100);
    }

    checkCollisions(map, axis) {
        const bounds = this.getBounds();
        this.grounded = false;

        for (const rect of map) {
            if (this.x < rect.x + rect.w && this.x + this.w > rect.x &&
                this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                
                if (axis === 'x') {
                    if (this.vx > 0) this.x = rect.x - this.w;
                    else if (this.vx < 0) this.x = rect.x + rect.w;
                    this.vx = 0;
                } else {
                    if (this.vy > 0) { 
                        this.y = rect.y - this.h;
                        this.grounded = true;
                        this.vy = 0;
                    } else if (this.vy < 0) { 
                        this.y = rect.y + rect.h;
                        this.vy = 0;
                    }
                }
            }
        }
        
        if (axis === 'y' && !this.grounded && this.vy >= 0) {
             for (const rect of map) {
                if (this.x < rect.x + rect.w - 2 && this.x + this.w > rect.x + 2 && 
                    Math.abs((this.y + this.h) - rect.y) < 2) {
                    this.grounded = true;
                    this.y = rect.y - this.h;
                    this.vy = 0;
                }
            }
        }
    }

    draw(ctx, camX, camY) {
        if (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) return; 
        
        drawVessel(ctx, this.x - camX, this.y - camY, this.w, this.h, this.facing, this.stretch.x, this.stretch.y, this.attacking, this.healing, false);
    }
}

// Helper to draw any vessel (local or remote)
function drawVessel(ctx, x, y, w, h, facing, scaleX, scaleY, attacking, healing, isRemote) {
    const cx = x + w/2;
    const cy = y + h; 

    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(facing * scaleX, scaleY);
    ctx.translate(-cx, -cy);

    // Cloak
    ctx.fillStyle = COLORS.cloak;
    ctx.beginPath();
    ctx.moveTo(cx, y + 15);
    ctx.lineTo(cx - 12, y + h);
    ctx.lineTo(cx + 12, y + h);
    ctx.fill();

    // Head
    ctx.fillStyle = isRemote ? COLORS.otherPlayer : COLORS.player;
    ctx.beginPath();
    // Horns
    ctx.moveTo(cx - 8, y);
    ctx.lineTo(cx - 8, y - 12);
    ctx.lineTo(cx - 4, y);
    
    ctx.moveTo(cx + 8, y);
    ctx.lineTo(cx + 8, y - 12);
    ctx.lineTo(cx + 4, y);
    ctx.fill();
    
    // Face
    ctx.beginPath();
    ctx.ellipse(cx, y + 10, 11, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // Eyes
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.ellipse(cx - 4, y + 10, 3, 5, 0, 0, Math.PI * 2);
    ctx.ellipse(cx + 4, y + 10, 3, 5, 0, 0, Math.PI * 2);
    ctx.fill();

    // Attack Swing
    if (attacking) {
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(cx + 10, y + 20, 30, -Math.PI/2, Math.PI/2);
        ctx.stroke();
        ctx.globalAlpha = 0.5;
        ctx.lineWidth = 10;
        ctx.stroke();
        ctx.globalAlpha = 1.0;
    }

    // Healing Effects
    if (healing) {
        ctx.fillStyle = 'white';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(cx, y + h/2, 25 + Math.random()*5, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.restore();
}

class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30);
        this.speed = 2;
        this.dir = 1;
        this.health = 3;
        this.dead = false;
    }
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) this.dead = true;
        SoundManager.playHit();
    }
    update(map, player) {
        if (this.dead) return;
        this.x += this.speed * this.dir;
        
        let hitWall = false;
        let aboutToFall = true;
        
        for (const rect of map) {
            if (this.x < rect.x + rect.w && this.x + this.w > rect.x && 
                this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                hitWall = true;
            }
            const checkX = this.dir === 1 ? this.x + this.w : this.x;
            if (checkX >= rect.x && checkX <= rect.x + rect.w && 
                this.y + this.h === rect.y) {
                aboutToFall = false;
            }
        }
        
        if (hitWall || aboutToFall) {
            this.dir *= -1;
            this.x += this.speed * this.dir * 2;
        }

        if (this.checkCollision(player)) {
            player.takeDamage(1, this.x);
        }
    }
    draw(ctx, camX, camY) {
        if (this.dead) return;
        ctx.fillStyle = COLORS.enemy;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.fillStyle = 'orange';
        ctx.fillRect(this.x - camX + (this.dir===1?20:5), this.y - camY + 5, 5, 5);
    }
}

// --- GAME CONTROLLER ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    player: null,
    enemies: [],
    particles: [],
    map: [],
    camera: {x: 0, y: 0, shake: 0},
    running: false,
    
    init: () => {
        Game.resize();
        window.addEventListener('resize', Game.resize);
        Input.init();
        
        Game.map.push({x: -500, y: 500, w: 2000, h: 100});
        Game.map.push({x: 300, y: 400, w: 200, h: 20});
        Game.map.push({x: 600, y: 300, w: 200, h: 20});
        Game.map.push({x: 100, y: 250, w: 100, h: 20});
        Game.map.push({x: -500, y: -500, w: 100, h: 1000});
        Game.map.push({x: 1400, y: -500, w: 100, h: 1000});

        Game.player = new Player(100, 300);
        Game.enemies.push(new Enemy(500, 470));
        Game.enemies.push(new Enemy(700, 270));
    },
    
    startGame: () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        Game.running = true;
        SoundManager.playMusic();
        requestAnimationFrame(Game.loop);
    },
    
    resumeGame: () => {
        document.getElementById('pause-menu').classList.add('hidden');
        Game.running = true;
        requestAnimationFrame(Game.loop);
    },
    
    saveGame: () => {
        const notif = document.getElementById('notification');
        notif.style.opacity = 1;
        setTimeout(() => notif.style.opacity = 0, 2000);
    },
    
    resize: () => {
        Game.canvas.width = window.innerWidth;
        Game.canvas.height = window.innerHeight;
    },
    
    sceneTransition: () => {
        const curtain = document.createElement('div');
        curtain.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:black;transition:opacity 0.5s;z-index:999;`;
        document.body.appendChild(curtain);
        setTimeout(() => curtain.style.opacity = 0, 100);
        setTimeout(() => curtain.remove(), 600);
    },
    
    updateHUD: () => {
        const hpBar = document.getElementById('health-bar');
        hpBar.innerHTML = '';
        for(let i=0; i<Game.player.maxHealth; i++) {
            const d = document.createElement('div');
            d.className = 'mask' + (i >= Game.player.health ? ' broken' : '');
            hpBar.appendChild(d);
        }
        
        const soulPct = (Game.player.soul / Game.player.maxSoul) * 100;
        document.getElementById('soul-meter').style.height = soulPct + '%';
    },

    loop: () => {
        if (!Game.running) return;
        if (Input.pause()) {
            Game.running = false;
            document.getElementById('pause-menu').classList.remove('hidden');
            return;
        }

        const ctx = Game.ctx;
        
        Game.player.update(Game.map, Game.enemies);
        
        Game.enemies.forEach(e => e.update(Game.map, Game.player));
        
        Game.particles.forEach((p, i) => {
            p.update();
            if(p.markedForDeletion) Game.particles.splice(i, 1);
        });

        if (window.Network && window.Network.connected) {
            window.Network.sendUpdate(Game.player);
        }

        let targetCamX = Game.player.x + Game.player.w/2 - Game.canvas.width/2;
        let targetCamY = Game.player.y + Game.player.h/2 - Game.canvas.height/2;
        
        if (targetCamY > 100) targetCamY = 100; 

        Game.camera.x += (targetCamX - Game.camera.x) * 0.1;
        Game.camera.y += (targetCamY - Game.camera.y) * 0.1;
        
        let shakeX = 0, shakeY = 0;
        if (Game.camera.shake > 0) {
            shakeX = (Math.random() - 0.5) * Game.camera.shake;
            shakeY = (Math.random() - 0.5) * Game.camera.shake;
            Game.camera.shake *= 0.9;
            if(Game.camera.shake < 0.5) Game.camera.shake = 0;
        }

        const cx = Game.camera.x + shakeX;
        const cy = Game.camera.y + shakeY;

        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, Game.canvas.width, Game.canvas.height);

        ctx.fillStyle = COLORS.platform;
        ctx.strokeStyle = COLORS.platformBorder;
        ctx.lineWidth = 2;
        for (const rect of Game.map) {
            ctx.fillRect(rect.x - cx, rect.y - cy, rect.w, rect.h);
            ctx.strokeRect(rect.x - cx, rect.y - cy, rect.w, rect.h);
        }

        if (window.Network && window.Network.remotePlayers) {
            Object.keys(window.Network.remotePlayers).forEach(key => {
                const p = window.Network.remotePlayers[key];
                
                // Draw Remote Vessel (Skin)
                // Use default width/height of player: 24, 40
                drawVessel(ctx, p.x - cx, p.y - cy, 24, 40, p.f || 1, 1, 1, p.a, false, true);

                // Name Tag
                ctx.fillStyle = '#aaa';
                ctx.font = '10px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(p.n || 'Vessel', p.x - cx + 12, p.y - cy - 10);
            });
        }

        Game.enemies.forEach(e => e.draw(ctx, cx, cy));

        Game.player.draw(ctx, cx, cy);

        Game.particles.forEach(p => p.draw(ctx, cx, cy));

        const grad = ctx.createRadialGradient(Game.canvas.width/2, Game.canvas.height/2, 200, Game.canvas.width/2, Game.canvas.height/2, 800);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, Game.canvas.width, Game.canvas.height);

        requestAnimationFrame(Game.loop);
    }
};

window.Game = Game;
window.onload = Game.init;

</script>
</body>
</html>
