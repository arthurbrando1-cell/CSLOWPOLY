<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GTA 3D Browser</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <!-- Three.js -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        
        /* HUD Styling */
        .hud-text { text-shadow: 2px 2px 0 #000; pointer-events: none; }
        .pointer-events-auto { pointer-events: auto; }
        
        /* Crosshair */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            transform: translate(-50%, -50%); pointer-events: none;
        }
        
        /* Minimap Transition */
        #minimap-container {
            transition: all 0.3s ease;
            cursor: pointer;
        }
        #minimap-container.expanded {
            width: 500px !important;
            height: 500px !important;
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) !important;
            border-radius: 10px;
            z-index: 50;
        }

        /* Scope Effect */
        .scope-overlay {
            background: radial-gradient(circle, transparent 50%, black 100%);
        }
    </style>
</head>
<body class="text-white">

    <!-- 3D Container -->
    <div id="game-container"></div>

    <!-- UI Overlay -->
    <div id="ui-layer" class="fixed inset-0 pointer-events-none z-10 flex flex-col justify-between p-4">
        
        <!-- Crosshair -->
        <div id="crosshair">
            <div class="w-1 h-5 bg-white absolute left-1/2 -translate-x-1/2"></div>
            <div class="w-5 h-1 bg-white absolute top-1/2 -translate-y-1/2"></div>
        </div>

        <!-- Top Right: Weapon & Money -->
        <div class="absolute top-4 right-4 flex flex-col items-end gap-2">
            <div class="text-5xl font-bold text-green-400 hud-text" id="moneyDisplay">$0</div>
            <div class="flex items-center gap-2 bg-black/60 p-2 rounded border border-gray-600">
                <span id="weaponName" class="font-bold text-yellow-400 text-xl">PISTOLA</span>
                <span id="ammoDisplay" class="text-2xl font-mono">∞</span>
            </div>
            <!-- Wanted Stars -->
            <div class="flex text-3xl hud-text" id="wantedLevel">
                <span class="text-gray-600">★</span><span class="text-gray-600">★</span><span class="text-gray-600">★</span><span class="text-gray-600">★</span><span class="text-gray-600">★</span>
            </div>
        </div>

        <!-- Top Left: Mission -->
        <div class="absolute top-4 left-4 bg-black/60 p-4 rounded border-l-4 border-yellow-500 max-w-sm" id="missionBox">
            <h3 class="font-bold text-yellow-400 uppercase text-lg">Missão Atual</h3>
            <p id="missionText" class="text-md">Pressione 'M' para iniciar uma missão.</p>
        </div>

        <!-- Center Notification -->
        <div id="notification" class="absolute top-1/4 left-1/2 transform -translate-x-1/2 text-4xl font-bold text-yellow-400 hud-text opacity-0 transition-opacity duration-1000 text-center bg-black/50 p-4 rounded">
            MISSÃO CUMPRIDA
        </div>
        
        <!-- Bottom UI -->
        <div class="w-full flex justify-between items-end mt-auto pointer-events-none">
            <!-- Stats & Controls -->
            <div class="flex flex-col gap-2 w-80">
                <div class="flex items-center gap-2">
                    <div class="w-10 h-10 bg-red-600 flex items-center justify-center rounded font-bold">HP</div>
                    <div class="flex-1 h-6 bg-gray-800 rounded overflow-hidden border border-gray-600 relative">
                        <div id="healthBar" class="h-full bg-red-500 w-full transition-all duration-200"></div>
                    </div>
                </div>
                <div class="text-xs text-gray-300 bg-black/50 p-2 rounded">
                    WASD: Mover | SHIFT: Correr | ESPAÇO: Pular<br>
                    MOUSE: Olhar/Atirar | F: Carro | R: Recarregar | B: Loja | M: Missão
                </div>
            </div>

            <!-- Minimap (Clickable via CSS/JS) -->
            <div id="minimap-container" class="w-56 h-56 bg-black/90 border-4 border-gray-500 rounded-full overflow-hidden relative shadow-2xl pointer-events-auto">
                <canvas id="minimapCanvas" width="300" height="300" class="w-full h-full object-cover"></canvas>
                <div class="absolute inset-0 flex items-center justify-center pointer-events-none">
                    <div class="w-2 h-2 bg-white rounded-full"></div>
                </div>
                <div class="absolute bottom-2 right-0 left-0 text-center text-[10px] text-gray-400 pointer-events-none">CLIQUE PARA AMPLIAR</div>
            </div>
        </div>
    </div>

    <!-- Shop Modal -->
    <div id="shopModal" class="fixed inset-0 bg-black/80 z-50 hidden flex items-center justify-center pointer-events-auto backdrop-blur-sm">
        <div class="bg-gray-800 p-8 rounded-lg border-2 border-yellow-500 w-[500px] shadow-2xl">
            <h2 class="text-3xl font-bold text-yellow-400 mb-6 text-center border-b border-gray-600 pb-2">AMMU-NATION</h2>
            <div class="space-y-3">
                <button onclick="window.game.buyItem('health')" class="w-full bg-gray-700 hover:bg-gray-600 p-4 rounded flex justify-between items-center group transition">
                    <div class="flex flex-col items-start">
                        <span class="font-bold text-lg group-hover:text-white">Kit Médico</span>
                        <span class="text-xs text-gray-400">Recupera 50% de HP</span>
                    </div>
                    <span class="text-green-400 font-bold text-xl">$200</span>
                </button>
                <button onclick="window.game.buyItem('ammo')" class="w-full bg-gray-700 hover:bg-gray-600 p-4 rounded flex justify-between items-center group transition">
                    <div class="flex flex-col items-start">
                        <span class="font-bold text-lg group-hover:text-white">Munição (Pack)</span>
                        <span class="text-xs text-gray-400">30 Balas para arma atual</span>
                    </div>
                    <span class="text-green-400 font-bold text-xl">$100</span>
                </button>
                <button onclick="window.game.buyItem('uzi')" class="w-full bg-gray-700 hover:bg-gray-600 p-4 rounded flex justify-between items-center group transition">
                    <div class="flex flex-col items-start">
                        <span class="font-bold text-lg group-hover:text-white">Micro SMG</span>
                        <span class="text-xs text-gray-400">Alta cadência, dano médio</span>
                    </div>
                    <span class="text-green-400 font-bold text-xl">$1500</span>
                </button>
                <button onclick="window.game.buyItem('ak47')" class="w-full bg-gray-700 hover:bg-gray-600 p-4 rounded flex justify-between items-center group transition">
                    <div class="flex flex-col items-start">
                        <span class="font-bold text-lg group-hover:text-white">Rifle AK-47</span>
                        <span class="text-xs text-gray-400">Alto dano, longo alcance</span>
                    </div>
                    <span class="text-green-400 font-bold text-xl">$3000</span>
                </button>
            </div>
            <button onclick="window.game.toggleShop()" class="mt-8 w-full bg-red-600 hover:bg-red-500 p-3 rounded font-bold text-white shadow-lg transition transform active:scale-95">FECHAR (B)</button>
        </div>
    </div>

    <!-- Main Game Script -->
    <script type="module">
        import * as THREE from 'three';

        // --- GAME CONFIG ---
        const CONFIG = {
            tileSize: 20,
            mapSize: 30, // 30x30 tiles
            gravity: -30,
            colors: {
                grass: 0x2d6a4f,
                road: 0x333333,
                sidewalk: 0x555555,
                building: [0x555555, 0x666666, 0x777777, 0x4a4a4a],
                player: 0xffc107,
                skin: 0xffdbac,
                shirt: 0x3b82f6
            }
        };

        // --- GLOBAL STATE ---
        const state = {
            money: 100,
            hp: 100,
            wanted: 0,
            wantedTimer: 0,
            weapon: 'pistol',
            weapons: {
                'pistol': { name: 'PISTOLA', damage: 15, delay: 0.5, ammo: 9999, spread: 0.05 },
                'uzi': { name: 'MICRO SMG', damage: 8, delay: 0.1, ammo: 0, spread: 0.15 },
                'ak47': { name: 'AK-47', damage: 25, delay: 0.15, ammo: 0, spread: 0.02 }
            },
            mission: { active: false, type: null, target: null, text: "Explore a cidade." }
        };

        // --- UTILS ---
        function rnd(min, max) { return Math.random() * (max - min) + min; }
        function dist(o1, o2) { return Math.sqrt((o1.x-o2.x)**2 + (o1.z-o2.z)**2); }

        // --- ASSETS GENERATION (Simple Geometry) ---
        function createHumanoidMesh(colorTop = CONFIG.colors.shirt, colorBottom = 0x222222) {
            const group = new THREE.Group();

            // Materials
            const matSkin = new THREE.MeshLambertMaterial({ color: CONFIG.colors.skin });
            const matTop = new THREE.MeshLambertMaterial({ color: colorTop });
            const matBottom = new THREE.MeshLambertMaterial({ color: colorBottom });

            // Torso
            const torsoGeo = new THREE.BoxGeometry(0.6, 0.7, 0.3);
            const torso = new THREE.Mesh(torsoGeo, matTop);
            torso.position.y = 1.05; // Legs height + half torso
            torso.castShadow = true;
            group.add(torso);
            group.torso = torso;

            // Head (Neck is implicit)
            const headGeo = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const head = new THREE.Mesh(headGeo, matSkin);
            head.position.y = 0.55; // Relative to torso
            torso.add(head);

            // Arms
            const armGeo = new THREE.BoxGeometry(0.2, 0.7, 0.2);
            
            const leftArm = new THREE.Mesh(armGeo, matSkin);
            leftArm.position.set(-0.45, 0.1, 0);
            // Pivot for rotation at shoulder
            const laGroup = new THREE.Group();
            laGroup.position.set(-0.45, 0.25, 0); // Shoulder pos
            leftArm.position.set(0, -0.25, 0);
            laGroup.add(leftArm);
            torso.add(laGroup);
            group.leftArm = laGroup;

            const rightArm = new THREE.Mesh(armGeo, matSkin);
            const raGroup = new THREE.Group();
            raGroup.position.set(0.45, 0.25, 0);
            rightArm.position.set(0, -0.25, 0);
            raGroup.add(rightArm);
            torso.add(raGroup);
            group.rightArm = raGroup;

            // Legs
            const legGeo = new THREE.BoxGeometry(0.25, 0.7, 0.25);
            
            const leftLeg = new THREE.Mesh(legGeo, matBottom);
            const llGroup = new THREE.Group();
            llGroup.position.set(-0.15, -0.35, 0); // Hip pos relative to torso
            leftLeg.position.set(0, -0.35, 0);
            llGroup.add(leftLeg);
            torso.add(llGroup);
            group.leftLeg = llGroup;

            const rightLeg = new THREE.Mesh(legGeo, matBottom);
            const rlGroup = new THREE.Group();
            rlGroup.position.set(0.15, -0.35, 0);
            rightLeg.position.set(0, -0.35, 0);
            rlGroup.add(rightLeg);
            torso.add(rlGroup);
            group.rightLeg = rlGroup;

            return group;
        }

        function createCarMesh(color) {
            const group = new THREE.Group();
            
            // Body
            const bodyGeo = new THREE.BoxGeometry(2.2, 0.8, 4.5);
            const matBody = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.6 });
            const body = new THREE.Mesh(bodyGeo, matBody);
            body.position.y = 0.6;
            body.castShadow = true;
            group.add(body);

            // Cabin
            const cabinGeo = new THREE.BoxGeometry(1.8, 0.6, 2.5);
            const matWindow = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.1, metalness: 0.8 });
            const cabin = new THREE.Mesh(cabinGeo, matWindow);
            cabin.position.set(0, 0.7, -0.2);
            body.add(cabin);

            // Wheels
            const wheelGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.3, 16);
            const matWheel = new THREE.MeshLambertMaterial({ color: 0x111111 });
            
            const wheels = [
                { x: -1, z: 1.2 }, { x: 1, z: 1.2 },
                { x: -1, z: -1.2 }, { x: 1, z: -1.2 }
            ];

            wheels.forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, matWheel);
                w.rotation.z = Math.PI / 2;
                w.position.set(pos.x, 0.4, pos.z);
                group.add(w);
            });
            
            // Headlights
            const lightGeo = new THREE.PlaneGeometry(0.5, 0.3);
            const matLight = new THREE.MeshBasicMaterial({ color: 0xffffcc });
            const hl1 = new THREE.Mesh(lightGeo, matLight);
            hl1.position.set(-0.6, 0.1, 2.26);
            hl1.rotation.y = 0; // Front is Z+? No, Box geometry default
            // Correct orientation: Box Z is depth.
            // Let's assume car 'forward' is +Z for now, or match player which is typically -Z.
            // Let's standardise: FORWARD is -Z (ThreeJS default). 
            // My box geometry was 4.5 deep (Z). 
            // So front is -2.25?
            // Wait, let's just rotate the mesh to match logic. 
            // In logic, I will move object along its Z axis.
            
            return group;
        }

        // --- CLASSES ---

        class Entity {
            constructor(x, z) {
                this.position = new THREE.Vector3(x, 0, z);
                this.rotation = 0;
                this.mesh = null;
                this.dead = false;
            }
            update(dt) {}
        }

        class Player extends Entity {
            constructor(scene, camera) {
                super(0, 0);
                this.camera = camera;
                this.mesh = createHumanoidMesh();
                scene.add(this.mesh);
                
                // Movement state
                this.velocity = new THREE.Vector3();
                this.onGround = true;
                this.speed = 10;
                this.inCar = false;
                this.car = null;
                
                // Animation
                this.animTime = 0;
                this.isMoving = false;
                
                // Shooting
                this.shootTimer = 0;
                this.cameraAngleY = 0;
                this.cameraAngleX = 0;
            }

            update(dt, input, world) {
                if (this.dead) return;

                if (this.inCar) {
                    this.updateCarMode(dt, input, world);
                } else {
                    this.updateWalkingMode(dt, input, world);
                }
            }

            updateWalkingMode(dt, input, world) {
                const moveSpeed = input.keys['ShiftLeft'] ? 12 : 6;
                const camDir = new THREE.Vector3();
                this.camera.getWorldDirection(camDir);
                camDir.y = 0; 
                camDir.normalize();
                
                const camRight = new THREE.Vector3(-camDir.z, 0, camDir.x);

                const direction = new THREE.Vector3();
                if (input.keys['KeyW']) direction.add(camDir);
                if (input.keys['KeyS']) direction.sub(camDir);
                if (input.keys['KeyA']) direction.sub(camRight);
                if (input.keys['KeyD']) direction.add(camRight);

                this.isMoving = direction.lengthSq() > 0.01;

                if (this.isMoving) {
                    direction.normalize();
                    // Rotate character to face movement
                    const targetRot = Math.atan2(direction.x, direction.z);
                    // Smooth rotation
                    let rotDiff = targetRot - this.mesh.rotation.y;
                    // Normalize angle
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    this.mesh.rotation.y += rotDiff * 10 * dt;

                    this.position.addScaledVector(direction, moveSpeed * dt);
                    
                    // Collision with buildings
                    this.handleCollision(world);
                }

                // Animation
                if (this.isMoving) {
                    this.animTime += dt * 10;
                    this.mesh.leftLeg.rotation.x = Math.sin(this.animTime) * 0.5;
                    this.mesh.rightLeg.rotation.x = Math.sin(this.animTime + Math.PI) * 0.5;
                    this.mesh.leftArm.rotation.x = Math.sin(this.animTime + Math.PI) * 0.5;
                    this.mesh.rightArm.rotation.x = Math.sin(this.animTime) * 0.5;
                } else {
                    this.mesh.leftLeg.rotation.x = 0;
                    this.mesh.rightLeg.rotation.x = 0;
                    this.mesh.leftArm.rotation.x = 0;
                    this.mesh.rightArm.rotation.x = 0;
                }

                // Apply Position
                this.mesh.position.copy(this.position);

                // Camera Follow (Third Person)
                const idealOffset = new THREE.Vector3(0, 4, 6); // Offset behind player
                // Rotate offset by mouse controls (simulated by orbital logic in input, but here we just follow rotation)
                // Actually, let's make camera control independent (MMO style)
                // For this demo, camera rotation is controlled by mouse, player moves relative to camera.
                
                // Position camera based on spherical coords
                const camDist = 6;
                const cx = this.position.x + Math.sin(this.cameraAngleY) * Math.cos(this.cameraAngleX) * camDist;
                const cy = this.position.y + 4 + Math.sin(this.cameraAngleX) * camDist; // Height
                const cz = this.position.z + Math.cos(this.cameraAngleY) * Math.cos(this.cameraAngleX) * camDist;
                
                this.camera.position.lerp(new THREE.Vector3(cx, cy, cz), 0.2);
                this.camera.lookAt(this.position.x, this.position.y + 2, this.position.z);

                // Shooting
                if (input.mouse.left && this.shootTimer <= 0) {
                    this.shoot(world);
                }
                this.shootTimer -= dt;
                
                // Aiming Arms
                if (input.mouse.right || input.mouse.left) {
                     this.mesh.rightArm.rotation.x = -1.5; // Raise arm
                     this.mesh.leftArm.rotation.x = -1.5;
                }

                // Interaction
                if (input.keys['KeyF'] && !this.fLock) {
                    this.tryEnterCar(world);
                    this.fLock = true;
                }
                if (!input.keys['KeyF']) this.fLock = false;
            }

            updateCarMode(dt, input, world) {
                // Car Controls
                if (input.keys['KeyW']) this.car.speed += 15 * dt;
                if (input.keys['KeyS']) this.car.speed -= 10 * dt;
                
                if (Math.abs(this.car.speed) > 0.5) {
                    const dir = Math.sign(this.car.speed);
                    if (input.keys['KeyA']) this.car.angle += 2.0 * dt * dir;
                    if (input.keys['KeyD']) this.car.angle -= 2.0 * dt * dir;
                }
                
                // Friction
                this.car.speed *= 0.98;

                // Physics
                this.car.mesh.rotation.y = this.car.angle;
                const vx = Math.sin(this.car.angle) * this.car.speed;
                const vz = Math.cos(this.car.angle) * this.car.speed;
                
                this.car.position.x += vx * dt;
                this.car.position.z += vz * dt;
                
                // Sync Mesh
                this.car.mesh.position.copy(this.car.position);

                // Collision with buildings
                if (world.checkCollision(this.car.position.x, this.car.position.z, 2)) {
                    this.car.speed *= -0.5;
                    this.car.position.x -= vx * dt * 2;
                    this.car.position.z -= vz * dt * 2;
                }

                // Camera follows car
                const cx = this.car.position.x - Math.sin(this.car.angle) * 8;
                const cz = this.car.position.z - Math.cos(this.car.angle) * 8;
                this.camera.position.lerp(new THREE.Vector3(cx, 6, cz), 0.1);
                this.camera.lookAt(this.car.position);

                // Exit
                if (input.keys['KeyF'] && !this.fLock) {
                    this.exitCar();
                    this.fLock = true;
                }
                if (!input.keys['KeyF']) this.fLock = false;

                // Update Player Pos to match car (hidden)
                this.position.copy(this.car.position);
            }

            handleCollision(world) {
                if (world.checkCollision(this.position.x, this.position.z, 0.5)) {
                    // Simple bounce back
                    this.position.sub(new THREE.Vector3(
                        Math.sin(this.mesh.rotation.y), 0, Math.cos(this.mesh.rotation.y)
                    ).multiplyScalar(0.2));
                }
                // Bounds
                const size = CONFIG.mapSize * CONFIG.tileSize / 2;
                this.position.x = Math.max(-size, Math.min(size, this.position.x));
                this.position.z = Math.max(-size, Math.min(size, this.position.z));
            }

            tryEnterCar(world) {
                let closest = null;
                let minDist = 4;
                world.cars.forEach(c => {
                    const d = dist(this, c);
                    if (d < minDist) {
                        minDist = d;
                        closest = c;
                    }
                });
                if (closest) {
                    this.inCar = true;
                    this.car = closest;
                    this.mesh.visible = false;
                }
            }

            exitCar() {
                this.inCar = false;
                this.mesh.visible = true;
                this.position.x += 2; // Offset
                this.car.speed = 0;
                this.car = null;
            }

            shoot(world) {
                const weapon = state.weapons[state.weapon];
                if (state.weapon !== 'pistol') {
                    if (weapon.ammo <= 0) {
                        state.weapon = 'pistol'; // fallback
                        document.getElementById('weaponName').innerText = "PISTOLA";
                        return;
                    }
                    weapon.ammo--;
                }
                this.shootTimer = weapon.delay;
                
                // Raycast from camera center
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0,0), this.camera);
                
                // Visual effect (Tracer)
                // Start from gun position (approximate)
                const startPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0)); 
                // Direction
                const direction = raycaster.ray.direction.clone();
                // Apply Spread
                direction.x += (Math.random()-0.5) * weapon.spread;
                direction.y += (Math.random()-0.5) * weapon.spread;
                direction.z += (Math.random()-0.5) * weapon.spread;
                direction.normalize();

                const endPos = startPos.clone().add(direction.multiplyScalar(100));
                
                // Check Hits
                // Filter meshes: NPCs
                const targets = world.npcs.map(n => n.mesh);
                const intersects = raycaster.intersectObjects(targets, true); // Recursive for groups
                
                if (intersects.length > 0) {
                    const hit = intersects[0];
                    if (hit.distance < 100) {
                        // Find NPC
                        const hitNPC = world.npcs.find(n => n.mesh === hit.object || n.mesh.getObjectById(hit.object.id));
                        if (hitNPC) {
                            hitNPC.takeDamage(weapon.damage);
                            // Visual hit
                            world.addParticle(hit.point, 0xff0000, 5);
                        }
                    }
                }

                // Tracer Line
                const mat = new THREE.LineBasicMaterial({ color: 0xffff00 });
                const geo = new THREE.BufferGeometry().setFromPoints([startPos, startPos.clone().add(direction.multiplyScalar(50))]);
                const line = new THREE.Line(geo, mat);
                world.scene.add(line);
                setTimeout(() => world.scene.remove(line), 50);

                // Update UI
                if (state.weapon !== 'pistol') document.getElementById('ammoDisplay').innerText = weapon.ammo;
            }
        }

        class NPC extends Entity {
            constructor(x, z, type='civilian', scene) {
                super(x, z);
                this.type = type; // 'civilian', 'enemy', 'police'
                this.hp = type === 'police' ? 60 : 30;
                this.mesh = createHumanoidMesh(type === 'police' ? 0x000088 : (type === 'enemy' ? 0x880000 : Math.random() * 0xffffff));
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                
                this.state = 'wander';
                this.timer = 0;
                this.target = null;
                this.speed = 3;
            }
            update(dt, player, world) {
                if (this.dead) return;
                
                const dToPlayer = dist(this.position, player.position);

                // Simple AI
                if (this.type === 'civilian') {
                    if (this.state === 'wander') {
                        this.timer -= dt;
                        if (this.timer <= 0) {
                            this.angle = Math.random() * Math.PI * 2;
                            this.timer = rnd(2, 5);
                        }
                        this.move(dt, this.angle, this.speed, world);
                    }
                    if (state.wanted > 0 && dToPlayer < 10) {
                        // Flee
                        const angle = Math.atan2(this.position.z - player.position.z, this.position.x - player.position.x);
                        this.move(dt, angle, 6, world);
                    }
                } else if (this.type === 'enemy' || this.type === 'police') {
                     if (dToPlayer < 20 || (this.type === 'police' && state.wanted > 0)) {
                         // Chase
                         const angle = Math.atan2(player.position.z - this.position.z, player.position.x - this.position.x);
                         this.move(dt, angle, 5, world);
                         // Attack logic could go here (shooting)
                     } else {
                         this.timer -= dt;
                         if (this.timer <= 0) {
                             this.angle = Math.random() * Math.PI * 2;
                             this.timer = rnd(2, 5);
                         }
                         this.move(dt, this.angle, 2, world);
                     }
                }
                
                this.mesh.position.copy(this.position);
            }
            
            move(dt, angle, speed, world) {
                const dx = Math.cos(angle) * speed * dt;
                const dz = Math.sin(angle) * speed * dt;
                
                if (!world.checkCollision(this.position.x + dx, this.position.z + dz, 0.5)) {
                    this.position.x += dx;
                    this.position.z += dz;
                    this.mesh.rotation.y = -angle + Math.PI/2; // Orient mesh
                    
                    // Animate legs
                    const t = Date.now() / 100;
                    this.mesh.leftLeg.rotation.x = Math.sin(t) * 0.5;
                    this.mesh.rightLeg.rotation.x = Math.sin(t + Math.PI) * 0.5;
                }
            }

            takeDamage(amt) {
                this.hp -= amt;
                if (this.hp <= 0) {
                    this.dead = true;
                    this.mesh.rotation.x = -Math.PI / 2; // Fall over
                    this.mesh.position.y = 0.2;
                    // Drop money
                    state.money += Math.floor(rnd(10, 50));
                    document.getElementById('moneyDisplay').innerText = '$' + state.money;
                    
                    // Wanted level
                    if (this.type === 'civilian' || this.type === 'police') {
                        state.wanted = Math.min(state.wanted + 0.5, 5);
                        updateWantedUI();
                    }

                    // Check Mission
                    if (state.mission.active && state.mission.type === 'kill' && state.mission.target === this) {
                        completeMission(1000);
                    }
                }
            }
        }

        class CarEntity extends Entity {
            constructor(x, z, scene) {
                super(x, z);
                this.mesh = createCarMesh(Math.random() * 0xffffff);
                this.mesh.position.copy(this.position);
                scene.add(this.mesh);
                this.angle = Math.random() * Math.PI * 2;
                this.speed = 0;
            }
        }

        class World {
            constructor(scene) {
                this.scene = scene;
                this.buildings = [];
                this.npcs = [];
                this.cars = [];
                this.particles = [];
                
                this.generateCity();
            }

            generateCity() {
                // Ground
                const size = CONFIG.mapSize * CONFIG.tileSize;
                const groundGeo = new THREE.PlaneGeometry(size, size);
                const groundMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.grass });
                const ground = new THREE.Mesh(groundGeo, groundMat);
                ground.rotation.x = -Math.PI / 2;
                ground.receiveShadow = true;
                this.scene.add(ground);

                // Roads (Grid)
                const roadMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.road });
                const rWidth = 8;
                
                // Simple grid generation
                for(let i = -size/2; i < size/2; i += 60) {
                     // Vertical Road
                     const rV = new THREE.Mesh(new THREE.PlaneGeometry(rWidth, size), roadMat);
                     rV.rotation.x = -Math.PI/2;
                     rV.position.set(i, 0.05, 0);
                     this.scene.add(rV);
                     
                     // Horizontal Road
                     const rH = new THREE.Mesh(new THREE.PlaneGeometry(size, rWidth), roadMat);
                     rH.rotation.x = -Math.PI/2;
                     rH.position.set(0, 0.05, i);
                     this.scene.add(rH);
                }

                // Buildings
                const buildMat = new THREE.MeshStandardMaterial({ color: 0x888888 });
                const windowMat = new THREE.MeshBasicMaterial({ color: 0xffffcc }); // lit windows
                
                for(let x = -size/2 + 20; x < size/2; x += rnd(30, 50)) {
                    for(let z = -size/2 + 20; z < size/2; z += rnd(30, 50)) {
                        // Check if close to road (crude check: if x or z is close to grid lines)
                        // Grid lines at -size/2, -size/2+60, etc.
                        let closeToRoad = false;
                        for(let r = -size/2; r < size/2; r += 60) {
                            if (Math.abs(x - r) < 10 || Math.abs(z - r) < 10) closeToRoad = true;
                        }

                        if (!closeToRoad) {
                            const h = rnd(10, 40);
                            const w = rnd(10, 20);
                            const d = rnd(10, 20);
                            
                            const geo = new THREE.BoxGeometry(w, h, d);
                            const mesh = new THREE.Mesh(geo, buildMat);
                            mesh.position.set(x, h/2, z);
                            mesh.castShadow = true;
                            this.scene.add(mesh);
                            
                            this.buildings.push({ x, z, w, d, h });
                        }
                    }
                }
            }

            checkCollision(x, z, radius) {
                for (let b of this.buildings) {
                    if (x > b.x - b.w/2 - radius && x < b.x + b.w/2 + radius &&
                        z > b.z - b.d/2 - radius && z < b.z + b.d/2 + radius) {
                        return true;
                    }
                }
                return false;
            }

            addParticle(pos, color, count) {
                // Simplified particle effect (just temporary meshes)
                // In full game, use PointsMaterial
            }
        }

        // --- MAIN GAME LOOP ---
        
        let camera, scene, renderer;
        let player, world;
        let lastTime = 0;

        const input = {
            keys: {},
            mouse: { x: 0, y: 0, left: false, right: false }
        };

        function init() {
            // Setup Three.js
            const container = document.getElementById('game-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); // Sky blue
            scene.fog = new THREE.Fog(0x87CEEB, 20, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            scene.add(dirLight);

            // World
            world = new World(scene);
            
            // Player
            player = new Player(scene, camera);
            
            // Spawn NPCs
            for(let i=0; i<30; i++) {
                let x = rnd(-200, 200);
                let z = rnd(-200, 200);
                if (!world.checkCollision(x, z, 1)) {
                    world.npcs.push(new NPC(x, z, 'civilian', scene));
                }
            }
            // Spawn Cars
            for(let i=0; i<10; i++) {
                let x = rnd(-200, 200);
                let z = rnd(-200, 200);
                if (!world.checkCollision(x, z, 4)) {
                    world.cars.push(new CarEntity(x, z, scene));
                }
            }

            // Events
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', e => input.keys[e.code] = true);
            window.addEventListener('keyup', e => {
                input.keys[e.code] = false;
                if (e.code === 'KeyM') startMission();
                if (e.code === 'KeyB') window.game.toggleShop();
                if (e.code === 'KeyR') reloadWeapon();
            });
            window.addEventListener('mousemove', e => {
                input.mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                input.mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                
                // Camera Rotation
                player.cameraAngleY -= e.movementX * 0.002;
                player.cameraAngleX -= e.movementY * 0.002;
                player.cameraAngleX = Math.max(-1.5, Math.min(1.5, player.cameraAngleX));
            });
            window.addEventListener('mousedown', e => {
                if (e.button === 0) input.mouse.left = true;
                if (e.button === 2) input.mouse.right = true;
                
                // Lock pointer
                if (document.pointerLockElement !== document.body && !document.getElementById('shopModal').classList.contains('flex')) {
                    document.body.requestPointerLock();
                }
            });
            window.addEventListener('mouseup', e => {
                if (e.button === 0) input.mouse.left = false;
                if (e.button === 2) input.mouse.right = false;
            });

            // Minimap expansion
            const mm = document.getElementById('minimap-container');
            mm.addEventListener('mousedown', (e) => {
                // Only if pointer is unlocked (shop open or ESC pressed)
                if (document.pointerLockElement === null) {
                    mm.classList.toggle('expanded');
                }
            });

            // Start Loop
            requestAnimationFrame(animate);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);
            
            const dt = Math.min((time - lastTime) / 1000, 0.1);
            lastTime = time;

            if (!document.getElementById('shopModal').classList.contains('hidden')) return; // Pause if shop open

            // Update Logic
            player.update(dt, input, world);
            world.npcs.forEach(n => n.update(dt, player, world));

            // Mission Logic
            if (state.mission.active && state.mission.type === 'go') {
                if (dist(player.position, state.mission.target) < 5) {
                    completeMission(500);
                }
            }

            // Render
            renderer.render(scene, camera);
            
            // Minimap Draw
            drawMinimap();
        }

        const mmCanvas = document.getElementById('minimapCanvas');
        const mmCtx = mmCanvas.getContext('2d');
        
        function drawMinimap() {
            mmCtx.fillStyle = '#000';
            mmCtx.fillRect(0, 0, 300, 300);
            
            mmCtx.save();
            mmCtx.translate(150, 150);
            // Rotate map so player forward is always UP? Or fixed North?
            // GTA style: Player arrow rotates, map fixed OR Map rotates. Let's do Fixed Map (North is Up)
            const scale = 2; // Zoom
            
            mmCtx.translate(-player.position.x * scale, -player.position.z * scale);

            // Draw Buildings
            mmCtx.fillStyle = '#444';
            world.buildings.forEach(b => {
                mmCtx.fillRect(b.x - b.w/2, b.z - b.d/2, b.w, b.d); // Fixed rect coords
            });

            // Draw Target
            if (state.mission.active && state.mission.target) {
                mmCtx.fillStyle = '#ffff00';
                const tx = state.mission.target.x || state.mission.target.position.x;
                const tz = state.mission.target.z || state.mission.target.position.z;
                mmCtx.beginPath();
                mmCtx.arc(tx, tz, 10, 0, Math.PI*2);
                mmCtx.fill();
            }

            // Draw NPCs
            world.npcs.forEach(n => {
                if(n.dead) return;
                mmCtx.fillStyle = n.type === 'enemy' ? 'red' : (n.type === 'police' ? 'blue' : 'white');
                mmCtx.beginPath();
                mmCtx.arc(n.position.x, n.position.z, 3, 0, Math.PI*2);
                mmCtx.fill();
            });

            mmCtx.restore();

            // Draw Player Arrow (Center)
            mmCtx.save();
            mmCtx.translate(150, 150);
            mmCtx.rotate(-player.mesh.rotation.y); // Rotate arrow
            mmCtx.fillStyle = '#ffc107';
            mmCtx.beginPath();
            mmCtx.moveTo(0, -6);
            mmCtx.lineTo(5, 6);
            mmCtx.lineTo(0, 4);
            mmCtx.lineTo(-5, 6);
            mmCtx.fill();
            mmCtx.restore();
        }

        // --- GAME LOGIC HELPERS ---

        function startMission() {
            if (state.mission.active) return;
            const type = Math.random() > 0.5 ? 'kill' : 'go';
            
            state.mission.active = true;
            state.mission.type = type;
            
            if (type === 'kill') {
                // Find random NPC or create new
                let enemy = new NPC(player.position.x + rnd(50, 100), player.position.z + rnd(50, 100), 'enemy', scene);
                enemy.hp = 150; // Boss
                world.npcs.push(enemy);
                state.mission.target = enemy;
                state.mission.text = "Mate o Alvo Vermelho!";
            } else {
                state.mission.target = { x: player.position.x + rnd(-100, 100), z: player.position.z + rnd(-100, 100) };
                state.mission.text = "Vá até o local marcado!";
            }
            updateUI();
        }

        function completeMission(reward) {
            state.mission.active = false;
            state.money += reward;
            state.mission.text = "Missão Cumprida! +$" + reward;
            showNotification("MISSÃO CUMPRIDA");
            updateUI();
        }

        function showNotification(text) {
            const el = document.getElementById('notification');
            el.innerText = text;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

        function updateUI() {
            document.getElementById('moneyDisplay').innerText = '$' + state.money;
            document.getElementById('missionText').innerText = state.mission.text;
            updateWantedUI();
        }

        function updateWantedUI() {
            const stars = document.getElementById('wantedLevel').children;
            const lvl = Math.floor(state.wanted);
            for(let i=0; i<5; i++) {
                stars[i].className = i < lvl ? 'text-yellow-500' : 'text-gray-600';
            }
        }

        function reloadWeapon() {
             // Simple reload logic
             console.log("Reloading...");
        }

        // Global functions for HTML
        window.game = {
            toggleShop: () => {
                const modal = document.getElementById('shopModal');
                const isHidden = modal.classList.contains('hidden');
                if (isHidden) {
                    modal.classList.remove('hidden');
                    modal.classList.add('flex');
                    document.exitPointerLock();
                } else {
                    modal.classList.add('hidden');
                    modal.classList.remove('flex');
                    document.body.requestPointerLock();
                }
            },
            buyItem: (item) => {
                if (item === 'health' && state.money >= 200) {
                    state.money -= 200;
                    state.hp = 100;
                    document.getElementById('healthBar').style.width = '100%';
                }
                else if (item === 'ammo' && state.money >= 100 && state.weapon !== 'pistol') {
                    state.money -= 100;
                    state.weapons[state.weapon].ammo += 30;
                    document.getElementById('ammoDisplay').innerText = state.weapons[state.weapon].ammo;
                }
                else if (item === 'uzi' && state.money >= 1500) {
                    state.money -= 1500;
                    state.weapon = 'uzi';
                    state.weapons['uzi'].ammo += 60;
                }
                else if (item === 'ak47' && state.money >= 3000) {
                    state.money -= 3000;
                    state.weapon = 'ak47';
                    state.weapons['ak47'].ammo += 60;
                }
                document.getElementById('moneyDisplay').innerText = '$' + state.money;
                document.getElementById('weaponName').innerText = state.weapons[state.weapon].name;
            }
        };

        // Start
        init();

    </script>
</body>
</html>d
