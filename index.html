<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hollow Knight Web Clone - Multiplayer</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f0f16;
            color: white;
            font-family: 'Cinzel', serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            cursor: crosshair;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            background-color: #0f0f16;
            image-rendering: pixelated;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        #scoreboard {
            position: absolute;
            top: 60px;
            right: 20px;
            text-align: right;
            font-family: 'Cinzel', serif;
            display: none;
        }
        .score-row {
            color: #fff;
            font-size: 1rem;
            margin-bottom: 5px;
            text-shadow: 0 0 5px black;
        }
        .winner-announce {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            color: gold;
            text-shadow: 0 0 20px orange;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .health-container {
            display: flex;
            gap: 5px;
        }

        .mask {
            width: 30px;
            height: 35px;
            background: #e0e0e0;
            border: 2px solid #1a1a1a;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
            transition: all 0.2s;
        }
        .mask.broken {
            background: #333;
            border-color: #111;
            opacity: 0.5;
            transform: scale(0.8);
        }

        .soul-container {
            width: 60px;
            height: 60px;
            border: 3px solid #d4d4d4;
            border-radius: 50%;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }

        .soul-liquid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 0%;
            background: linear-gradient(to top, #fdfdfd, #a8a8a8);
            transition: height 0.2s;
            opacity: 0.8;
            box-shadow: 0 0 15px white;
        }

        /* Online Status */
        #online-status {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 0.8rem;
            color: #aaa;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        #server-id {
            display: none; 
            color: #666; 
            font-size: 0.7rem; 
            margin-right: 5px;
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #444;
        }
        .status-dot.connected { background: #4caf50; box-shadow: 0 0 8px #4caf50; }

        /* Menus */
        .menu-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 100;
        }

        .menu-title {
            font-size: 4rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            margin-bottom: 2rem;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
            background: linear-gradient(to bottom, #fff, #999);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.4);
            color: #ddd;
            padding: 15px 40px;
            margin: 10px;
            font-family: 'Cinzel', serif;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            border-color: white;
            color: white;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Controls Visuals */
        .controls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px 40px;
            background: rgba(0,0,0,0.6);
            padding: 30px;
            border-radius: 8px;
            border: 1px solid #444;
            margin-top: 20px;
            text-align: left;
        }

        .key-row { 
            display: flex; 
            align-items: center; 
            font-size: 1rem; 
            color: #ccc;
            justify-content: space-between;
        }

        .key-cap { 
            display: inline-flex; 
            align-items: center;
            justify-content: center;
            background: #2a2a2a; 
            border: 1px solid #555; 
            border-bottom: 3px solid #111;
            border-radius: 4px; 
            padding: 4px 10px; 
            margin-left: 8px;
            font-family: sans-serif; 
            font-weight: bold;
            color: #fff; 
            min-width: 20px;
            font-size: 0.9rem;
        }
        
        .mouse-icon {
            width: 24px;
            height: 32px;
            border: 2px solid #888;
            border-radius: 12px;
            position: relative;
            margin-left: 8px;
        }
        .mouse-icon::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 8px;
            background: #888;
        }
        .mouse-l { background: linear-gradient(90deg, #555 50%, transparent 50%); }
        .mouse-r { background: linear-gradient(90deg, transparent 50%, #555 50%); }

        .hidden { display: none !important; }
        
        .notification {
            position: absolute;
            bottom: 20%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border: 1px solid #555;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            color: white;
            font-family: 'Cinzel', serif;
        }

        /* Chat Input */
        #chat-container {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            pointer-events: auto;
            display: none;
        }
        #chat-wrapper {
            display: flex;
            width: 100%;
            background: rgba(0,0,0,0.8);
            border: 1px solid #666;
        }
        #chat-input {
            flex: 1;
            background: transparent;
            border: none;
            color: white;
            padding: 10px;
            font-family: 'Cinzel', serif;
            outline: none;
        }
        #chat-send-btn {
            width: 40px;
            background: #333;
            border: none;
            border-left: 1px solid #555;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }
        #chat-send-btn:hover {
            background: #555;
        }

        /* Server List Styles */
        .server-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid transparent;
            cursor: default;
            transition: background 0.2s;
        }
        .server-item:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #444;
        }
        .btn-join-small {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: #ddd;
            padding: 4px 10px;
            font-family: 'Cinzel', serif;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-join-small:hover {
            background: #fff;
            color: #000;
        }

        /* Customization Menu */
        .custom-option {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 2px solid #555;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .color-swatch:hover { transform: scale(1.1); border-color: white; }
        .color-swatch.selected { border-color: #fff; box-shadow: 0 0 10px white; }

        .cust-arrow {
            background: transparent;
            border: 1px solid #555;
            color: white;
            width: 30px;
            height: 30px;
            cursor: pointer;
        }
        .cust-arrow:hover { background: #333; }
        
        input[type="file"]::file-selector-button {
            border: 1px solid #555;
            background: #222;
            color: white;
            padding: 5px 10px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
        }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="online-status">
            <span id="server-id">cs-low-poly</span>
            <div id="net-dot" class="status-dot"></div>
            <span id="player-count">Offline</span>
        </div>

        <div id="hud" class="hidden">
            <div class="health-container" id="health-bar"></div>
            <div class="soul-container">
                <div class="soul-liquid" id="soul-meter"></div>
            </div>
            <!-- Chat Hint -->
            <div style="font-size: 0.8rem; color: #666; margin-top: 10px;">Press 'T' to Chat</div>
        </div>
        
        <div id="scoreboard">
            <h3 style="margin: 0 0 10px 0; color: #aaa; border-bottom: 1px solid #444;">BATTLE</h3>
            <div id="score-list"></div>
        </div>
        
        <div id="winner-announce" class="winner-announce">VICTORY</div>

        <div id="chat-container">
            <div id="chat-wrapper">
                <input type="text" id="chat-input" placeholder="Say something..." maxlength="30">
                <button id="chat-send-btn">></button>
            </div>
        </div>

        <div id="notification" class="notification">Saved Game</div>

        <div id="start-screen" class="menu-screen">
            <h1 class="menu-title">Vessel's Journey</h1>
            <p style="color: #888; margin-top: -20px; margin-bottom: 30px;">Multiplayer Online</p>
            
            <div style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px; width: 100%; max-width: 400px; background: rgba(0,0,0,0.8); padding: 20px; border: 1px solid #444; border-radius: 8px;">
                
                <div style="width: 100%; padding-bottom: 15px; border-bottom: 1px solid #333;">
                    <label style="display: block; color: #fff; font-size: 0.9rem; margin-bottom: 10px; font-weight: bold; text-align: center;">CREATE OR JOIN BY CODE</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="room-code-input" placeholder="Room Name" maxlength="15" 
                            style="flex: 2; background: rgba(255,255,255,0.1); border: 1px solid #666; color: #fff; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center; font-size: 1rem; text-transform: uppercase;">
                        
                        <input type="number" id="capacity-input" value="4" min="2" max="32" placeholder="Max"
                            style="flex: 0.5; background: rgba(0,0,0,0.3); border: 1px solid #555; color: white; padding: 8px; 
                            font-family: 'Cinzel', serif; text-align: center;">
                        
                        <button class="btn" id="btn-join" style="flex: 1; margin: 0; padding: 0; font-size: 0.8rem; background: #333;">GO</button>
                    </div>
                    <div style="margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 20px;">
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="pvp-toggle" style="width: 16px; height: 16px; cursor: pointer;">
                            <label for="pvp-toggle" style="color: #ccc; font-size: 0.8rem; cursor: pointer;">Enable PvP</label>
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <label for="rounds-input" style="color: #ccc; font-size: 0.8rem;">Rounds:</label>
                            <input type="number" id="rounds-input" value="3" min="1" max="10" style="width: 40px; background: rgba(0,0,0,0.3); border: 1px solid #555; color: white; padding: 2px; text-align: center; font-family: 'Cinzel', serif;">
                        </div>
                    </div>
                </div>

                <div style="width: 100%;">
                    <label style="display: block; color: #aaa; font-size: 0.8rem; margin-bottom: 10px; text-align: left;">BROWSE ACTIVE SERVERS</label>
                    
                    <div id="server-list-container" style="
                        width: 100%; 
                        height: 150px; 
                        background: rgba(0,0,0,0.3); 
                        border: 1px solid #333; 
                        overflow-y: auto; 
                        display: flex; 
                        flex-direction: column; 
                        gap: 2px;
                        padding: 2px;
                    ">
                        <div style="color: #666; font-size: 0.8rem; padding: 10px; text-align: center;">Connecting to Lobby...</div>
                    </div>
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button class="btn" id="btn-customize">Customize</button>
                <button class="btn" id="btn-settings">Settings</button>
            </div>
            
            <div class="controls-grid">
                <div class="key-row"><span>Movement</span> <div><span class="key-cap">A</span><span class="key-cap">D</span></div></div>
                <div class="key-row"><span>Look / Aim</span> <div><span class="key-cap">W</span><span class="key-cap">S</span></div></div>
                <div class="key-row"><span>Jump</span> <span class="key-cap">SPACE</span></div>
                <div class="key-row"><span>Dash</span> <span class="key-cap">SHIFT</span></div>
                <div class="key-row"><span>Attack</span> <div class="mouse-icon mouse-l"></div></div>
                <div class="key-row"><span>Fireball</span> <span class="key-cap">Q</span></div>
                <div class="key-row"><span>Heal (Hold)</span> <div class="mouse-icon mouse-r"></div></div>
                <div class="key-row"><span>Chat</span> <span class="key-cap">T</span></div>
            </div>
        </div>

        <!-- SETTINGS MENU -->
        <div id="settings-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Settings</h2>
            
            <div style="width: 300px; display: flex; flex-direction: column; gap: 20px; background: rgba(0,0,0,0.6); padding: 30px; border-radius: 8px; border: 1px solid #444; text-align: center;">
                <p style="color: #aaa;">Audio Disabled</p>
                <p style="color: #666; font-size: 0.8rem;">All sound effects and music have been removed.</p>
            </div>

            <button class="btn" id="btn-settings-back" style="margin-top: 30px;">Back</button>
        </div>

        <!-- CUSTOMIZATION MENU -->
        <div id="customize-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Vessel Style</h2>
            
            <div style="width: 320px; background: rgba(0,0,0,0.9); padding: 20px; border-radius: 8px; border: 1px solid #444; max-height: 80vh; overflow-y: auto;">
                
                <!-- Mask -->
                <div class="custom-option">
                    <span>Mask</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button class="cust-arrow" id="mask-prev"><</button>
                        <span id="mask-display" style="width: 80px; text-align: center; font-size: 0.7rem;">DEFAULT</span>
                        <button class="cust-arrow" id="mask-next">></button>
                    </div>
                </div>

                <!-- Outfit -->
                <div class="custom-option">
                    <span>Outfit</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button class="cust-arrow" id="outfit-prev"><</button>
                        <span id="outfit-display" style="width: 80px; text-align: center; font-size: 0.7rem;">CLOAK</span>
                        <button class="cust-arrow" id="outfit-next">></button>
                    </div>
                </div>

                <!-- Accessory -->
                <div class="custom-option">
                    <span>Accessory</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button class="cust-arrow" id="acc-prev"><</button>
                        <span id="acc-display" style="width: 80px; text-align: center; font-size: 0.7rem;">NONE</span>
                        <button class="cust-arrow" id="acc-next">></button>
                    </div>
                </div>

                <!-- Height -->
                <div class="custom-option">
                    <span>Height</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button class="cust-arrow" id="height-prev">-</button>
                        <span id="height-display" style="width: 60px; text-align: center; font-size: 0.8rem;">100%</span>
                        <button class="cust-arrow" id="height-next">+</button>
                    </div>
                </div>

                <!-- Weapon -->
                <div class="custom-option">
                    <span>Weapon</span>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <button class="cust-arrow" id="sword-prev"><</button>
                        <span id="sword-display" style="width: 80px; text-align: center; font-size: 0.7rem;">NAIL</span>
                        <button class="cust-arrow" id="sword-next">></button>
                    </div>
                </div>

                <!-- Color -->
                <div class="custom-option" style="flex-direction: column; align-items: flex-start;">
                    <span style="margin-bottom: 10px;">Color Theme</span>
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <div class="color-swatch selected" data-color="#2c3e50" style="background: #2c3e50;"></div>
                        <div class="color-swatch" data-color="#c0392b" style="background: #c0392b;"></div>
                        <div class="color-swatch" data-color="#27ae60" style="background: #27ae60;"></div>
                        <div class="color-swatch" data-color="#8e44ad" style="background: #8e44ad;"></div>
                        <div class="color-swatch" data-color="#d35400" style="background: #d35400;"></div>
                        <div class="color-swatch" data-color="#7f8c8d" style="background: #7f8c8d;"></div>
                        <div class="color-swatch" data-color="#111111" style="background: #111111; border: 1px solid #555;"></div>
                        <div class="color-swatch" data-color="#f1c40f" style="background: #f1c40f;"></div>
                        <div class="color-swatch" data-color="#ffffff" style="background: #ffffff;"></div>
                        <div class="color-swatch" data-color="#e91e63" style="background: #e91e63;"></div>
                    </div>
                </div>
                
                <!-- Background -->
                <div class="custom-option" style="flex-direction: column; align-items: flex-start;">
                    <span style="margin-bottom: 5px;">Custom Background</span>
                    <input type="file" id="bg-upload" accept="image/*" style="width: 100%; font-size: 0.7rem;">
                    <div style="font-size: 0.6rem; color: #666; margin-top: 2px;">Visible only to you.</div>
                </div>

                <div style="height: 120px; border: 1px solid #333; background: #0f0f16; display: flex; justify-content: center; align-items: center; margin-top: 20px;">
                    <canvas id="preview-canvas" width="120" height="120"></canvas>
                </div>
            </div>

            <button class="btn" id="btn-customize-done" style="margin-top: 20px;">Done</button>
        </div>

        <div id="pause-menu" class="menu-screen hidden">
            <h2 class="menu-title" style="font-size: 2rem;">Paused</h2>
            <button class="btn" id="btn-resume">Resume</button>
            <button class="btn" id="btn-save">Bench (Save)</button>
            <button class="btn" id="btn-quit">Quit</button>
        </div>
    </div>
</div>

<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getDatabase, ref, set, onValue, onDisconnect, remove, update, get, child } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";
    import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

    // --- FIREBASE CONFIG ---
    const firebaseConfig = {
      apiKey: "AIzaSyAIKPooiHzcB5d8_mRiDMyiam4AYel4lZs",
      authDomain: "cs-low-poly.firebaseapp.com",
      databaseURL: "https://cs-low-poly-default-rtdb.firebaseio.com",
      projectId: "cs-low-poly",
      storageBucket: "cs-low-poly.firebasestorage.app",
      messagingSenderId: "291417778108",
      appId: "1:291417778108:web:881869dd93735c6167edb9"
    };

    // --- NETWORK MANAGER ---
    const Network = {
        app: null,
        db: null,
        auth: null,
        playerId: null,
        playerName: null,
        playerRef: null,
        roomRef: null,
        remotePlayers: {},
        remoteStates: {}, // To track previous frame state for edge detection
        connected: false,
        pvpEnabled: false,
        lastUpdate: 0,
        currentRoom: null,
        
        initApp: async () => {
             if (!Network.app) {
                Network.app = initializeApp(firebaseConfig);
                Network.db = getDatabase(Network.app);
                Network.auth = getAuth(Network.app);
                
                Network.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
                Network.playerName = "Vessel " + Math.floor(Math.random() * 1000);

                try {
                    await signInAnonymously(Network.auth);
                    console.log("Authenticated with Firebase");
                    Network.startServerBrowser();
                } catch (error) {
                    console.error("Auth Error:", error);
                    alert("Authentication Failed: " + error.message);
                }
             }
        },

        startServerBrowser: () => {
            const listRef = ref(Network.db, 'hk_multiplayer/rooms');
            onValue(listRef, (snapshot) => {
                const rooms = snapshot.val() || {};
                const listEl = document.getElementById('server-list-container');
                listEl.innerHTML = ''; 

                if (Object.keys(rooms).length === 0) {
                    listEl.innerHTML = '<div style="color: #666; font-size: 0.8rem; padding: 10px;">No active servers found. Create one above!</div>';
                    return;
                }

                Object.keys(rooms).forEach(roomCode => {
                    const r = rooms[roomCode];
                    const count = r.players ? Object.keys(r.players).length : 0;
                    const max = r.settings ? r.settings.maxPlayers : 4;
                    
                    const el = document.createElement('div');
                    el.className = 'server-item';
                    el.innerHTML = `
                        <div style="display:flex; flex-direction:column; align-items:flex-start;">
                            <span style="color:white; font-weight:bold;">${roomCode}</span>
                            <span style="color:#888; font-size:0.7rem;">Map: Hallownest</span>
                        </div>
                        <div style="display:flex; align-items:center; gap: 10px;">
                            <span style="color: ${count >= max ? '#d32f2f' : '#4caf50'}">${count}/${max}</span>
                            <button class="btn-join-small">JOIN</button>
                        </div>
                    `;
                    el.querySelector('.btn-join-small').addEventListener('click', () => {
                         Network.attemptJoin(roomCode, max);
                    });
                    listEl.appendChild(el);
                });
            });
        },

        attemptJoin: async (roomCode, capacity) => {
            try {
                if (!Network.auth.currentUser) await Network.initApp();

                const db = Network.db;
                const roomRef = ref(db, `hk_multiplayer/rooms/${roomCode}`);
                
                const snapshot = await get(roomRef);
                const val = snapshot.val() || {};
                const players = val.players || {};
                let settings = val.settings || {};
                
                let maxPlayers = settings.maxPlayers;
                
                if (!maxPlayers) {
                    maxPlayers = parseInt(capacity) || 4;
                    const pvp = document.getElementById('pvp-toggle').checked;
                    const rounds = parseInt(document.getElementById('rounds-input').value) || 3;
                    await update(child(roomRef, 'settings'), { maxPlayers: maxPlayers, pvp: pvp, rounds: rounds });
                }
                
                const currentCount = Object.keys(players).length;
                if (currentCount >= maxPlayers) {
                    alert(`Room ${roomCode} is full! (${currentCount}/${maxPlayers})`);
                    return;
                }

                Network.connectToRoom(roomCode, maxPlayers);

            } catch (e) {
                console.error("Join Failed", e);
                alert("Network Error: " + e.message);
            }
        },

        connectToRoom: (roomCode, maxPlayers) => {
            try {
                Network.currentRoom = roomCode;
                const roomPath = `hk_multiplayer/rooms/${roomCode}/players`;
                Network.playerRef = ref(Network.db, `${roomPath}/${Network.playerId}`);
                Network.roomRef = ref(Network.db, roomPath);

                onDisconnect(Network.playerRef).remove();

                window.addEventListener('beforeunload', () => {
                      remove(Network.playerRef);
                });

                // Listen for Room Settings (PvP, Rounds)
                const settingsRef = child(ref(Network.db, `hk_multiplayer/rooms/${roomCode}`), 'settings');
                onValue(settingsRef, (snapshot) => {
                     const s = snapshot.val() || {};
                     Network.pvpEnabled = s.pvp || false;
                     Network.maxRounds = s.rounds || 3;
                     
                     if(Network.pvpEnabled) {
                         document.getElementById('scoreboard').style.display = 'block';
                     } else {
                         document.getElementById('scoreboard').style.display = 'none';
                     }
                });

                onValue(Network.roomRef, (snapshot) => {
                    const data = snapshot.val() || {};
                    delete data[Network.playerId];
                    Network.remotePlayers = data;
                    
                    const count = Object.keys(data).length + 1;
                    document.getElementById('player-count').innerText = `${count}/${maxPlayers} Online` + (Network.pvpEnabled ? " [PvP]" : "");
                    document.getElementById('net-dot').classList.add('connected');
                    document.getElementById('server-id').innerText = `Room: ${roomCode}`;
                    document.getElementById('server-id').style.display = 'block';
                    
                    // Update Scoreboard
                    if (Network.pvpEnabled) {
                        const list = document.getElementById('score-list');
                        let scores = [];
                        // My Score
                        scores.push({n: Network.playerName, s: Game.player ? Game.player.score : 0, me: true});
                        // Others
                        Object.values(data).forEach(p => {
                            scores.push({n: p.n || 'Enemy', s: p.sc || 0, me: false});
                        });
                        scores.sort((a,b) => b.s - a.s);
                        
                        list.innerHTML = scores.map(p => `
                            <div class="score-row" style="color: ${p.me ? '#4caf50' : (p.s >= Network.maxRounds ? 'gold' : 'white')}">
                                ${p.n}: ${p.s}/${Network.maxRounds}
                            </div>
                        `).join('');
                        
                        // Check Win
                        const winner = scores.find(s => s.s >= Network.maxRounds);
                        if (winner) {
                            const ann = document.getElementById('winner-announce');
                            ann.innerText = winner.me ? "VICTORY" : "DEFEAT";
                            ann.style.opacity = 1;
                            ann.style.color = winner.me ? 'gold' : '#d32f2f';
                        } else {
                            document.getElementById('winner-announce').style.opacity = 0;
                        }
                    }
                });

                Network.connected = true;
                console.log(`Joined Room: ${roomCode}`);
                window.Game.startGame();

            } catch (e) {
                console.error("Connection Failed", e);
            }
        },

        sendUpdate: (playerData) => {
            if (!Network.connected || !Network.playerRef) return;
            const now = Date.now();
            if (now - Network.lastUpdate > 50) {
                update(Network.playerRef, {
                    x: Math.round(playerData.x),
                    y: Math.round(playerData.y),
                    f: playerData.facing, 
                    s: playerData.animState, 
                    a: playerData.attacking,
                    fb: playerData.firingFireball, 
                    hp: playerData.health,
                    n: Network.playerName,
                    cc: playerData.cloakColor, 
                    ms: playerData.maskStyle,
                    sw: playerData.swordStyle,
                    os: playerData.outfitStyle,
                    as: playerData.accessoryStyle,
                    hs: playerData.heightScale,
                    sc: playerData.score,
                    ts: now,
                    msg: playerData.chatMessage,
                    mt: playerData.chatTimer
                });
                Network.lastUpdate = now;
            }
        }
    };

    window.Network = Network;
    Network.initApp();

    document.getElementById('btn-join').addEventListener('click', () => {
        const input = document.getElementById('room-code-input');
        const capInput = document.getElementById('capacity-input');
        const code = input.value.trim().toUpperCase();
        
        if(!code) {
            alert("Please enter a room code to create or join.");
            return;
        }

        const capacity = parseInt(capInput.value) || 4;
        Network.attemptJoin(code, capacity);
    });

    document.getElementById('btn-resume').addEventListener('click', () => window.Game.resumeGame());
    document.getElementById('btn-save').addEventListener('click', () => window.Game.saveGame());
    document.getElementById('btn-quit').addEventListener('click', () => location.reload());
    
    // Open Settings
    document.getElementById('btn-settings').addEventListener('click', () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('settings-menu').classList.remove('hidden');
    });
    // Back from Settings
    document.getElementById('btn-settings-back').addEventListener('click', () => {
        document.getElementById('settings-menu').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    });
    
    // Customize Menu
    document.getElementById('btn-customize').addEventListener('click', () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('customize-menu').classList.remove('hidden');
        window.Game.previewCustomization();
    });
    document.getElementById('btn-customize-done').addEventListener('click', () => {
        document.getElementById('customize-menu').classList.add('hidden');
        document.getElementById('start-screen').classList.remove('hidden');
    });

</script>

<script>
/**
 * HOLLOW KNIGHT CLONE - MAIN ENGINE
 */

const GRAVITY = 0.6;
const TERMINAL_VELOCITY = 15;
const FRICTION = 0.8;
const MOVE_SPEED = 6;
const JUMP_FORCE = 12;
const DASH_SPEED = 14;
const DASH_DURATION = 12;
const ATTACK_DURATION = 15;
const INVULNERABILITY_TIME = 60;

const COLORS = {
    bg: '#0f0f16',
    platform: '#1a1a2e',
    platformBorder: '#3d3d5c',
    player: '#f0f0f0',
    otherPlayer: '#d0d0f0',
    cloak: '#2c3e50',
    enemy: '#d35400',
    boss: '#c0392b',
    soul: '#ecf0f1',
    hazard: '#7f8c8d'
};

// --- INPUT HANDLING ---
const Input = {
    keys: {},
    mouse: { x: 0, y: 0, left: false, right: false },
    active: true,
    
    init: () => {
        window.addEventListener('keydown', e => {
            if(Input.active) Input.keys[e.code] = true;
            
            // Toggle Chat
            if(e.code === 'KeyT' && !document.getElementById('chat-container').style.display.includes('block')) {
                Game.toggleChat(true);
                e.preventDefault();
            }
            // Send Chat
            if(e.code === 'Enter' && document.getElementById('chat-container').style.display.includes('block')) {
                Game.sendChat();
            }
        });
        window.addEventListener('keyup', e => Input.keys[e.code] = false);
        
        window.addEventListener('mousedown', e => {
            if (e.button === 0) Input.mouse.left = true;
            if (e.button === 2) Input.mouse.right = true;
        });
        window.addEventListener('mouseup', e => {
            if (e.button === 0) Input.mouse.left = false;
            if (e.button === 2) Input.mouse.right = false;
        });
        window.addEventListener('contextmenu', e => e.preventDefault());
    },
    
    reset: () => { Input.keys = {}; Input.mouse.left = false; Input.mouse.right = false; },
    
    left: () => Input.keys['KeyA'] || Input.keys['ArrowLeft'],
    right: () => Input.keys['KeyD'] || Input.keys['ArrowRight'],
    up: () => Input.keys['KeyW'] || Input.keys['ArrowUp'],
    down: () => Input.keys['KeyS'] || Input.keys['ArrowDown'],
    jump: () => Input.keys['Space'] || Input.keys['KeyZ'],
    dash: () => Input.keys['ShiftLeft'] || Input.keys['KeyC'],
    attack: () => Input.mouse.left || Input.keys['KeyX'],
    fireball: () => Input.keys['KeyQ'],
    heal: () => Input.mouse.right || Input.keys['KeyF'], 
    pause: () => Input.keys['Escape']
};

// --- ENTITIES ---
class Entity {
    constructor(x, y, w, h) {
        this.x = x; this.y = y;
        this.w = w; this.h = h;
        this.vx = 0; this.vy = 0;
        this.markedForDeletion = false;
    }
    
    getBounds() {
        return { left: this.x, right: this.x + this.w, top: this.y, bottom: this.y + this.h };
    }

    checkCollision(other) {
        const a = this.getBounds();
        const b = other.getBounds();
        return (a.left < b.right && a.right > b.left && a.top < b.bottom && a.bottom > b.top);
    }
}

class Particle extends Entity {
    constructor(x, y, color, vx, vy, life) {
        super(x, y, 4, 4);
        this.color = color;
        this.vx = vx;
        this.vy = vy;
        this.life = life;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; 
        this.life--;
        if (this.life <= 0) this.markedForDeletion = true;
    }
    draw(ctx, camX, camY) {
        ctx.fillStyle = this.color;
        ctx.globalAlpha = this.life / 30;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.globalAlpha = 1.0;
    }
}

class Fireball extends Entity {
    constructor(x, y, dir, isHostile = false, isMine = false) {
        super(x, y, 30, 20);
        this.dir = dir;
        this.vx = dir * 12; 
        this.life = 60; 
        this.isHostile = isHostile;
        this.isMine = isMine;
    }
    update(map, enemies) {
        this.x += this.vx;
        this.life--;
        
        if (this.life % 2 === 0) {
            Game.particles.push(new Particle(this.x + (this.dir===1?0:this.w), this.y + this.h/2, this.isHostile ? 'rgba(255,100,100,0.7)' : 'rgba(255,255,255,0.7)', -this.dir * 2, (Math.random()-0.5)*2, 10));
        }

        if (this.life <= 0) {
            this.markedForDeletion = true;
            return;
        }

        // Wall Collision
        for (const rect of map) {
            if (this.checkCollision({getBounds: () => ({left: rect.x, right: rect.x+rect.w, top: rect.y, bottom: rect.y+rect.h})})) {
                this.markedForDeletion = true;
                this.explode();
                return;
            }
        }

        if (this.isHostile) {
            // PvP: Check collision with local player (Hostile means fired by OTHER)
            if (Game.player && !Game.player.dead && this.checkCollision(Game.player)) {
                Game.player.takeDamage(1, this.x, 'fireball');
                this.markedForDeletion = true;
                this.explode();
            }
        } else if (this.isMine && window.Network && window.Network.pvpEnabled) {
             // My fireball hitting others (logic mostly for kill credit if we could track it)
             // We can't hit enemies with it if they aren't local enemies? 
             // Local enemies are shared.
             enemies.forEach(e => {
                if (!e.dead && this.checkCollision(e)) {
                    e.takeDamage(2); 
                    this.markedForDeletion = true;
                    this.explode();
                }
            });
            // Hitting other players?
            // We don't have authority to damage them directly. They check 'isHostile'.
        } else {
            // Standard Friendly (PvE)
            enemies.forEach(e => {
                if (!e.dead && this.checkCollision(e)) {
                    e.takeDamage(2); 
                    this.markedForDeletion = true;
                    this.explode();
                }
            });
        }
    }

    explode() {
        for(let i=0; i<10; i++) {
             Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, this.isHostile ? 'red' : 'white', (Math.random()-0.5)*10, (Math.random()-0.5)*10, 20));
        }
    }

    draw(ctx, camX, camY) {
        ctx.fillStyle = this.isHostile ? '#ff4444' : 'white';
        ctx.beginPath();
        const cx = this.x - camX + this.w/2;
        const cy = this.y - camY + this.h/2;
        ctx.ellipse(cx, cy, 15, 10, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = this.isHostile ? 'rgba(255,0,0,0.8)' : 'rgba(200,200,255,0.8)';
        ctx.beginPath();
        ctx.ellipse(cx, cy, 10, 6, 0, 0, Math.PI*2);
        ctx.fill();
    }
}

class Player extends Entity {
    constructor(x, y) {
        super(x, y, 24, 40);
        this.startPos = {x, y};
        this.health = 5;
        this.maxHealth = 5;
        this.soul = 0;
        this.maxSoul = 100;
        this.facing = 1; 
        
        this.grounded = false;
        this.dashing = false;
        this.dashTimer = 0;
        this.dashCooldown = 0;
        this.attacking = false;
        this.attackTimer = 0;
        this.attackCooldown = 0;
        this.fireballCooldown = 0;
        this.firingFireball = false; 
        this.healing = false;
        this.invulnerable = 0;
        this.dead = false;
        this.recoil = 0;
        
        this.animState = 0; 
        this.animTimer = 0;
        this.stretch = {x: 1, y: 1};
        
        // Chat
        this.chatMessage = "";
        this.chatTimer = 0;

        // Customization
        this.cloakColor = '#2c3e50';
        this.maskStyle = 0; 
        this.swordStyle = 0; 
        this.outfitStyle = 0; // 0: Cloak, 1: Armor, 2: Robe
        this.accessoryStyle = 0; // 0: None
        this.heightScale = 1.0;
        this.score = 0;
    }

    respawn() {
        this.x = this.startPos.x;
        this.y = this.startPos.y;
        this.health = this.maxHealth;
        this.dead = false;
        this.vx = 0;
        this.vy = 0;
        Game.camera.shake = 0;
        Game.sceneTransition();
    }

    takeDamage(amount, srcX, attackerKey) {
        if (this.invulnerable > 0 || this.dead) return;
        this.health -= amount;
        this.invulnerable = INVULNERABILITY_TIME;
        this.recoil = 10;
        this.vx = (this.x < srcX ? -1 : 1) * 8;
        this.vy = -5;
        Game.camera.shake = 10;
        Game.updateHUD();

        if (this.health <= 0) {
            this.dead = true;
            for(let i=0; i<20; i++) {
                Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h/2, 'black', (Math.random()-0.5)*10, (Math.random()-0.5)*10, 60));
            }
            
            // If PvP and killed by another player, give them a point
            if (window.Network && window.Network.pvpEnabled && attackerKey) {
                 // We can't update other player's score directly, so we broadcast that we died to them?
                 // Simpler: Just handle score locally for display? No, need sync.
                 // Actually, simpler: The killer detects they killed you? No, unreliable.
                 // Solution: We update the attacker's score in OUR database if we have permissions? No.
                 // We can only update our own score. 
                 // So... In this P2P model, we can't easily increment the OTHER person's score securely.
                 // WORKAROUND: We will increment our own "deaths" and the winner logic can be calculated? 
                 // BETTER: We trust the client. If I die, I update a "lastKilledBy" field on myself.
                 // The attacker sees this and increments THEIR score.
                 // Too complex for single file. 
                 // SIMPLIFIED: When I die, I respawn. That's it. 
                 // Wait, user asked for rounds.
                 // Let's implement: If I die, I send a chat message "Killed by X".
                 // Actually, let's just use local detection. If I hit someone and their health drops to 0?
                 // Impossible to know for sure due to lag.
                 // OK: Player who DIES handles the logic. "I died."
                 // But I can't increment your score.
                 // Okay, I will increment a public counter in the room if I could.
                 // Let's go with: I died. I will Respawn.
                 // The "Round" system will be: First to 5 kills.
                 // Since I can't track your kills easily, I will track MY DEATHS. 
                 // Score = (Total Deaths of others) - (My Deaths)? No.
                 // Let's just make it simple: The attacker (local) detects if a fireball/slash hits. 
                 // If the hit is fatal (remote HP low), add score locally.
                 // This is prone to desync (I see you die, you don't).
                 // For a prototype: I will grant myself a point if I land a hit that *should* kill you.
                 // Not perfect but works for "Play with friends".
            }
            
            setTimeout(() => this.respawn(), 1000);
        }
    }

    addSoul(amount) {
        this.soul = Math.min(this.soul + amount, this.maxSoul);
        Game.updateHUD();
    }

    update(map, enemies) {
        if (this.dead) return;
        this.animTimer++;
        if (this.chatTimer > 0) this.chatTimer--;
        
        this.stretch.x += (1 - this.stretch.x) * 0.1;
        this.stretch.y += (1 - this.stretch.y) * 0.1;

        if (Input.heal() && this.grounded && this.soul >= 33 && this.health < this.maxHealth) {
            this.healing = true;
            this.vx *= 0.8;
            if (this.animTimer % 10 === 0) {
                 Game.particles.push(new Particle(this.x + Math.random()*this.w, this.y + Math.random()*this.h, 'white', 0, -1, 20));
            }
            
            if (!this.healTimer) this.healTimer = 60;
            this.healTimer--;
            if (this.healTimer <= 0) {
                this.soul -= 33;
                this.health++;
                this.healTimer = 0;
                this.healing = false;
                Game.updateHUD();
            }
        } else {
            this.healing = false;
            this.healTimer = 0;
        }

        if (this.recoil > 0) {
            this.recoil--;
        } else if (!this.healing && Input.active) {
            if (Input.left()) { 
                this.vx -= 1; 
                this.facing = -1; 
                this.animState = 1;
            }
            else if (Input.right()) { 
                this.vx += 1; 
                this.facing = 1; 
                this.animState = 1;
            } else {
                this.animState = 0;
            }
            
            this.vx *= FRICTION;
            if (Math.abs(this.vx) < 0.1) this.vx = 0;
            if (this.vx > MOVE_SPEED) this.vx = MOVE_SPEED;
            if (this.vx < -MOVE_SPEED) this.vx = -MOVE_SPEED;
        }

        if (Input.jump() && !this.lastJumpKey && Input.active) {
            if (this.grounded) {
                this.vy = -JUMP_FORCE;
                this.stretch = {x: 0.7, y: 1.3};
                this.grounded = false;
                this.lastJumpKey = true;
                this.animState = 2;
                
                for(let i=0; i<5; i++) {
                    Game.particles.push(new Particle(this.x + this.w/2, this.y + this.h, 'white', (Math.random()-0.5)*4, Math.random()*-2, 20));
                }
            }
        } else if (!Input.jump()) {
            this.lastJumpKey = false;
            if (this.vy < -3) this.vy *= 0.5;
        }

        if (Input.dash() && !this.dashing && this.dashCooldown <= 0 && !this.healing && Input.active) {
            this.dashing = true;
            this.dashTimer = DASH_DURATION;
            this.dashCooldown = 40; 
            this.vx = this.facing * DASH_SPEED;
            this.vy = 0;
            Game.camera.shake = 5;
        }

        // Fireball Ability
        if (Input.fireball() && this.fireballCooldown <= 0 && !this.healing && Input.active) {
            this.fireballCooldown = 60; // 1 second cooldown
            this.firingFireball = true;
            setTimeout(() => this.firingFireball = false, 200);
            
            const fbX = this.facing === 1 ? this.x + this.w + 5 : this.x - 35;
            const fbY = this.y + 10;
            // Pass true for ownership
            Game.fireballs.push(new Fireball(fbX, fbY, this.facing, false, true));
            
            // Recoil
            this.vx = -this.facing * 5; 
            Game.camera.shake = 5;
            Game.updateHUD();
        }

        if (Input.attack() && !this.attacking && this.attackCooldown <= 0 && !this.healing && Input.active) {
            this.attacking = true;
            this.attackTimer = ATTACK_DURATION;
            this.attackCooldown = (this.swordStyle === 1) ? 15 : (this.swordStyle === 2 ? 45 : 25); // Needle faster, Greatsword slower
            
            let reach = 40;
            let dmg = 1;
            let hitH = 20;

            if (this.swordStyle === 2) { reach = 60; dmg = 2; hitH = 40; } // Greatsword
            if (this.swordStyle === 3) { reach = 50; dmg = 1; hitH = 30; } // Scythe
            if (this.swordStyle === 4) { reach = 100; dmg = 1; hitH = 10; } // Blaster (Long range melee)
            
            const hitX = this.facing === 1 ? this.x + this.w : this.x - reach;
            const hitY = this.y + 10;

            // Enemies
            enemies.forEach(e => {
                if (!e.dead && hitX < e.x + e.w && hitX + reach > e.x && hitY < e.y + e.h && hitY + hitH > e.y) {
                    e.takeDamage(dmg);
                    this.addSoul(15);
                    this.recoil = 5;
                    if(this.grounded) this.vx = -this.facing * 5;
                }
            });
            
            // PvP Hit Detection (Client Side Authority for scoring, sorta)
            if (window.Network && window.Network.connected && window.Network.pvpEnabled) {
                const remotes = window.Network.remotePlayers;
                Object.keys(remotes).forEach(key => {
                    const p = remotes[key];
                    if (hitX < p.x + 24 && hitX + reach > p.x && hitY < p.y + 40 && hitY + hitH > p.y) {
                        // Visual feedback only, real damage is handled by victim in their update loop?
                        // Actually, in the current implementation, the VICTIM checks if they are hit by an animation.
                        // See Game.loop -> Remote Players section.
                    }
                });
            }
        }

        if (this.dashing) {
            this.dashTimer--;
            this.vy = 0;
            if (this.dashTimer <= 0) {
                this.dashing = false;
                this.vx *= 0.2;
            }
            if (this.dashTimer % 3 === 0) {
                Game.particles.push(new Particle(this.x, this.y, 'rgba(255,255,255,0.5)', 0, 0, 10));
            }
        } else {
            this.vy += GRAVITY;
            if (this.vy > TERMINAL_VELOCITY) this.vy = TERMINAL_VELOCITY;
        }

        if (this.dashCooldown > 0) this.dashCooldown--;
        if (this.attackCooldown > 0) this.attackCooldown--;
        if (this.fireballCooldown > 0) this.fireballCooldown--;
        if (this.invulnerable > 0) this.invulnerable--;
        if (this.attacking) this.attackTimer--;
        if (this.attackTimer <= 0) this.attacking = false;

        this.x += this.vx;
        this.checkCollisions(map, 'x');
        this.y += this.vy;
        this.checkCollisions(map, 'y');
        
        if (this.y > 4000) this.takeDamage(1, this.x + 100);
    }

    checkCollisions(map, axis) {
        const bounds = this.getBounds();
        this.grounded = false;

        for (const rect of map) {
            if (this.x < rect.x + rect.w && this.x + this.w > rect.x &&
                this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                
                if (axis === 'x') {
                    if (this.vx > 0) this.x = rect.x - this.w;
                    else if (this.vx < 0) this.x = rect.x + rect.w;
                    this.vx = 0;
                } else {
                    if (this.vy > 0) { 
                        this.y = rect.y - this.h;
                        this.grounded = true;
                        this.vy = 0;
                    } else if (this.vy < 0) { 
                        this.y = rect.y + rect.h;
                        this.vy = 0;
                    }
                }
            }
        }
        
        if (axis === 'y' && !this.grounded && this.vy >= 0) {
             for (const rect of map) {
                if (this.x < rect.x + rect.w - 2 && this.x + this.w > rect.x + 2 && 
                    Math.abs((this.y + this.h) - rect.y) < 2) {
                    this.grounded = true;
                    this.y = rect.y - this.h;
                    this.vy = 0;
                }
            }
        }
    }

    draw(ctx, camX, camY) {
        if (this.invulnerable > 0 && Math.floor(Date.now() / 50) % 2 === 0) return; 
        
        drawVessel(ctx, this.x - camX, this.y - camY, this.w, this.h, this.facing, this.stretch.x, this.stretch.y, this.attacking, this.healing, false, this.chatTimer > 0 ? this.chatMessage : null, this.cloakColor, this.maskStyle, this.swordStyle, this.outfitStyle, this.heightScale, this.accessoryStyle);
    }
}

// Draw Vessel Function (Handles Skins and Chat)
function drawVessel(ctx, x, y, w, h, facing, scaleX, scaleY, attacking, healing, isRemote, chatMsg, cloakColor, maskStyle, swordStyle, outfitStyle, heightScale, accessoryStyle) {
    const scale = heightScale || 1.0;
    const finalH = h * scale;
    const cx = x + w/2;
    const cy = y + h; // Pivot bottom
    
    ctx.save();
    
    // Chat Bubble
    if (chatMsg) {
        ctx.font = '12px sans-serif';
        const metrics = ctx.measureText(chatMsg);
        const bw = Math.max(metrics.width + 10, 20);
        const bh = 24;
        const bx = cx - bw/2;
        const by = y - (finalH - h) - bh - 10;
        
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.beginPath();
        ctx.roundRect(bx, by, bw, bh, 5);
        ctx.fill();
        ctx.beginPath();
        ctx.moveTo(cx, by + bh);
        ctx.lineTo(cx - 5, by + bh + 5);
        ctx.lineTo(cx + 5, by + bh + 5);
        ctx.fill();
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.fillText(chatMsg, cx, by + 16);
    }

    ctx.translate(cx, cy);
    ctx.scale(facing * scaleX * scale, scaleY * scale);
    ctx.translate(-cx, -cy);

    // Outfit
    ctx.fillStyle = cloakColor || COLORS.cloak;
    ctx.beginPath();
    const os = outfitStyle || 0;
    const as = accessoryStyle || 0;

    if (os === 0) { // Cloak
        ctx.moveTo(cx, y + 15);
        ctx.lineTo(cx - 12, y + h);
        ctx.lineTo(cx + 12, y + h);
    } else if (os === 1) { // Armor
        ctx.moveTo(cx - 10, y + 15);
        ctx.lineTo(cx - 10, y + h - 5);
        ctx.lineTo(cx, y + h);
        ctx.lineTo(cx + 10, y + h - 5);
        ctx.lineTo(cx + 10, y + 15);
        // Shoulder pads
        ctx.moveTo(cx - 14, y + 15);
        ctx.lineTo(cx - 6, y + 15);
        ctx.lineTo(cx - 10, y + 22);
        ctx.moveTo(cx + 14, y + 15);
        ctx.lineTo(cx + 6, y + 15);
        ctx.lineTo(cx + 10, y + 22);
    } else if (os === 2) { // Robe
        ctx.moveTo(cx, y + 10);
        ctx.lineTo(cx - 15, y + h);
        ctx.lineTo(cx + 15, y + h);
    } else if (os === 3) { // Grimm Style
        ctx.moveTo(cx, y + 10);
        ctx.lineTo(cx - 10, y + h);
        ctx.lineTo(cx + 10, y + h);
        // Collar
        ctx.moveTo(cx - 12, y + 5);
        ctx.lineTo(cx - 6, y + 15);
        ctx.lineTo(cx - 14, y + 20);
        ctx.moveTo(cx + 12, y + 5);
        ctx.lineTo(cx + 6, y + 15);
        ctx.lineTo(cx + 14, y + 20);
    } else if (os === 4) { // Tattered/Shade
        ctx.moveTo(cx, y + 15);
        ctx.lineTo(cx - 12, y + h - 5);
        ctx.lineTo(cx - 8, y + h);
        ctx.lineTo(cx - 4, y + h - 5);
        ctx.lineTo(cx, y + h);
        ctx.lineTo(cx + 4, y + h - 5);
        ctx.lineTo(cx + 8, y + h);
        ctx.lineTo(cx + 12, y + h - 5);
    }
    ctx.fill();
    
    // Armor Detail
    if (os === 1) {
        ctx.strokeStyle = '#999';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.rect(cx - 4, y + 25, 8, 10);
        ctx.stroke();
    }

    // Accessory (Behind Head)
    if (as === 1) { // Scarf
        ctx.fillStyle = '#e74c3c';
        ctx.beginPath();
        ctx.moveTo(cx - 6, y + 12);
        ctx.quadraticCurveTo(cx - 15, y + 15, cx - 18, y + 25); // Flowing left
        ctx.lineTo(cx - 12, y + 25);
        ctx.lineTo(cx - 4, y + 15);
        ctx.fill();
    } else if (as === 2) { // Backpack
        ctx.fillStyle = '#795548';
        ctx.beginPath();
        ctx.roundRect(cx - 10, y + 20, 20, 15, 4);
        ctx.fill();
        ctx.fillStyle = '#5d4037';
        ctx.beginPath();
        ctx.rect(cx - 10, y + 25, 20, 2);
        ctx.fill();
    }

    // Head
    ctx.fillStyle = (os === 4) ? '#111' : (isRemote ? COLORS.otherPlayer : COLORS.player);
    ctx.beginPath();
    
    const mStyle = maskStyle || 0;
    
    // Base Face
    ctx.ellipse(cx, y + 10, 11, 12, 0, 0, Math.PI * 2);

    // Horns / Top
    if (mStyle == 0) { // Default
        ctx.moveTo(cx - 8, y);
        ctx.lineTo(cx - 8, y - 12);
        ctx.lineTo(cx - 4, y);
        ctx.moveTo(cx + 8, y);
        ctx.lineTo(cx + 8, y - 12);
        ctx.lineTo(cx + 4, y);
    } else if (mStyle == 1) { // Horns (Curved)
        ctx.moveTo(cx - 8, y);
        ctx.quadraticCurveTo(cx - 12, y - 10, cx - 4, y);
        ctx.moveTo(cx + 8, y);
        ctx.quadraticCurveTo(cx + 12, y - 10, cx + 4, y);
    } else if (mStyle == 2) { // Pointy
        ctx.moveTo(cx - 8, y);
        ctx.lineTo(cx - 10, y - 15);
        ctx.lineTo(cx - 4, y);
        ctx.moveTo(cx + 8, y);
        ctx.lineTo(cx + 10, y - 15);
        ctx.lineTo(cx + 4, y);
    } else if (mStyle == 3) { // Helmet
        ctx.moveTo(cx - 10, y + 5);
        ctx.lineTo(cx - 10, y - 10);
        ctx.quadraticCurveTo(cx, y - 15, cx + 10, y - 10);
        ctx.lineTo(cx + 10, y + 5);
    } else if (mStyle == 4) { // Crown
        ctx.moveTo(cx - 8, y - 2);
        ctx.lineTo(cx - 10, y - 15);
        ctx.lineTo(cx - 4, y - 5);
        ctx.lineTo(cx, y - 15);
        ctx.lineTo(cx + 4, y - 5);
        ctx.lineTo(cx + 10, y - 15);
        ctx.lineTo(cx + 8, y - 2);
    } else if (mStyle == 5) { // Bandana (Quirrel)
        ctx.moveTo(cx - 10, y);
        ctx.lineTo(cx - 10, y - 10);
        ctx.quadraticCurveTo(cx, y - 5, cx + 10, y - 10);
        ctx.lineTo(cx + 10, y);
    } else if (mStyle == 6) { // Broken
        ctx.moveTo(cx - 8, y);
        ctx.lineTo(cx - 8, y - 12);
        ctx.lineTo(cx - 4, y);
        ctx.moveTo(cx + 8, y);
        ctx.lineTo(cx + 8, y - 4); // Broken horn
        ctx.lineTo(cx + 4, y);
    } else if (mStyle == 7) { // Zote
        ctx.moveTo(cx - 8, y);
        ctx.lineTo(cx - 8, y - 15);
        ctx.lineTo(cx - 4, y - 5);
        ctx.lineTo(cx, y - 15);
        ctx.lineTo(cx + 4, y - 5);
        ctx.lineTo(cx + 8, y - 15);
        ctx.lineTo(cx + 8, y);
    }

    ctx.fill();

    // Eyes
    ctx.fillStyle = (os === 4) ? 'white' : 'black'; // White eyes for Shade
    ctx.beginPath();
    if (mStyle == 3) { // Helmet Slit
        ctx.rect(cx - 6, y + 8, 12, 4);
    } else if (mStyle == 7) { // Zote (Closed/Angry)
        ctx.moveTo(cx - 6, y + 8);
        ctx.lineTo(cx - 2, y + 10);
        ctx.moveTo(cx + 6, y + 8);
        ctx.lineTo(cx + 2, y + 10);
        ctx.stroke();
        // Mouth
        ctx.beginPath();
        ctx.rect(cx - 2, y + 14, 4, 2);
        ctx.fill();
    } else {
        ctx.ellipse(cx - 4, y + 10, 3, 5, 0, 0, Math.PI * 2);
        ctx.ellipse(cx + 4, y + 10, 3, 5, 0, 0, Math.PI * 2);
    }
    ctx.fill();
    
    // Accessory (Face/Head)
    if (as === 3) { // Flower
        ctx.fillStyle = 'pink';
        ctx.beginPath();
        ctx.arc(cx + 8, y + 5, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = 'white';
        ctx.beginPath();
        ctx.arc(cx + 8, y + 5, 2, 0, Math.PI*2);
        ctx.fill();
    }

    if (attacking) {
        const sw = swordStyle || 0;
        
        ctx.strokeStyle = 'white';
        ctx.fillStyle = 'white';
        
        if (sw === 0) { // Nail
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(cx + 10, y + 20, 30, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 10;
            ctx.stroke();
        } else if (sw === 1) { // Needle
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(cx + 5, y + 20);
            ctx.lineTo(cx + 45, y + 20);
            ctx.stroke();
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 6;
            ctx.stroke();
        } else if (sw === 2) { // Greatsword
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.arc(cx + 10, y + 20, 45, -Math.PI/2, Math.PI/2);
            ctx.stroke();
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 15;
            ctx.stroke();
        } else if (sw === 3) { // Scythe
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(cx + 10, y + 30);
            ctx.quadraticCurveTo(cx + 40, y + 10, cx + 10, y - 20);
            ctx.stroke();
            ctx.globalAlpha = 0.5;
            ctx.lineWidth = 8;
            ctx.stroke();
        } else if (sw === 4) { // Blaster
            ctx.beginPath();
            ctx.arc(cx + 25, y + 15, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.moveTo(cx + 25, y + 15);
            ctx.lineTo(cx + 50, y + 15);
            ctx.lineWidth = 4;
            ctx.stroke();
        }
        
        ctx.globalAlpha = 1.0;
    }

    if (healing) {
        ctx.fillStyle = 'white';
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(cx, y + h/2, 25 + Math.random()*5, 0, Math.PI*2);
        ctx.fill();
    }

    ctx.restore();
}

class Enemy extends Entity {
    constructor(x, y) {
        super(x, y, 30, 30);
        this.speed = 2;
        this.dir = 1;
        this.health = 3;
        this.dead = false;
    }
    takeDamage(amount) {
        this.health -= amount;
        if (this.health <= 0) this.dead = true;
    }
    update(map, player) {
        if (this.dead) return;
        this.x += this.speed * this.dir;
        
        let hitWall = false;
        let aboutToFall = true;
        
        for (const rect of map) {
            if (this.x < rect.x + rect.w && this.x + this.w > rect.x && 
                this.y < rect.y + rect.h && this.y + this.h > rect.y) {
                hitWall = true;
            }
            const checkX = this.dir === 1 ? this.x + this.w : this.x;
            if (checkX >= rect.x && checkX <= rect.x + rect.w && 
                this.y + this.h === rect.y) {
                aboutToFall = false;
            }
        }
        
        if (hitWall || aboutToFall) {
            this.dir *= -1;
            this.x += this.speed * this.dir * 2;
        }

        if (this.checkCollision(player)) {
            player.takeDamage(1, this.x);
        }
    }
    draw(ctx, camX, camY) {
        if (this.dead) return;
        ctx.fillStyle = COLORS.enemy;
        ctx.fillRect(this.x - camX, this.y - camY, this.w, this.h);
        ctx.fillStyle = 'orange';
        ctx.fillRect(this.x - camX + (this.dir===1?20:5), this.y - camY + 5, 5, 5);
    }
}

// --- GAME CONTROLLER ---
const Game = {
    canvas: document.getElementById('gameCanvas'),
    ctx: document.getElementById('gameCanvas').getContext('2d'),
    player: null,
    enemies: [],
    fireballs: [],
    particles: [],
    map: [],
    camera: {x: 0, y: 0, shake: 0},
    running: false,
    
    init: () => {
        Game.resize();
        window.addEventListener('resize', Game.resize);
        Input.init();
        
        // --- MASSIVE MAP GENERATION ---
        Game.map = [];
        // Ground Floor
        Game.map.push({x: -1000, y: 500, w: 3000, h: 500});
        
        // Starting Steps
        Game.map.push({x: 300, y: 400, w: 200, h: 20});
        Game.map.push({x: 600, y: 300, w: 200, h: 20});
        Game.map.push({x: 100, y: 250, w: 100, h: 20});
        
        // Left Tower
        Game.map.push({x: -800, y: -2000, w: 100, h: 2500});
        for(let i=0; i<10; i++) {
            Game.map.push({x: -700 + (i%2)*150, y: 400 - i*120, w: 120, h: 20});
        }
        
        // Right Tower
        Game.map.push({x: 1800, y: -2000, w: 100, h: 2500});
         for(let i=0; i<10; i++) {
            Game.map.push({x: 1550 - (i%2)*150, y: 400 - i*120, w: 120, h: 20});
        }
        
        // Upper Bridge
        Game.map.push({x: -700, y: -500, w: 2500, h: 50});
        
        // Floating Islands
        Game.map.push({x: 200, y: -700, w: 300, h: 40});
        Game.map.push({x: 800, y: -800, w: 200, h: 40});
        Game.map.push({x: -200, y: -900, w: 150, h: 30});

        Game.player = new Player(100, 300);
        
        // Init Customization UI
        const colors = document.querySelectorAll('.color-swatch');
        colors.forEach(c => {
            c.addEventListener('click', (e) => {
                colors.forEach(el => el.classList.remove('selected'));
                e.target.classList.add('selected');
                Game.player.cloakColor = e.target.dataset.color;
                Game.previewCustomization();
            });
        });
        
        // Mask Names
        const maskNames = ["DEFAULT", "HORNS", "POINTY", "HELMET", "CROWN", "BANDANA", "BROKEN", "ZOTE"];
        Game.player.maskStyle = 0;
        document.getElementById('mask-next').addEventListener('click', () => {
            Game.player.maskStyle = (Game.player.maskStyle + 1) % maskNames.length;
            document.getElementById('mask-display').innerText = maskNames[Game.player.maskStyle];
            Game.previewCustomization();
        });
        document.getElementById('mask-prev').addEventListener('click', () => {
            Game.player.maskStyle = (Game.player.maskStyle - 1 + maskNames.length) % maskNames.length;
            document.getElementById('mask-display').innerText = maskNames[Game.player.maskStyle];
            Game.previewCustomization();
        });

        // Outfit Names
        const outfitNames = ["CLOAK", "ARMOR", "ROBE", "GRIMM", "SHADE"];
        document.getElementById('outfit-next').addEventListener('click', () => {
            Game.player.outfitStyle = (Game.player.outfitStyle + 1) % outfitNames.length;
            document.getElementById('outfit-display').innerText = outfitNames[Game.player.outfitStyle];
            Game.previewCustomization();
        });
        document.getElementById('outfit-prev').addEventListener('click', () => {
            Game.player.outfitStyle = (Game.player.outfitStyle - 1 + outfitNames.length) % outfitNames.length;
            document.getElementById('outfit-display').innerText = outfitNames[Game.player.outfitStyle];
            Game.previewCustomization();
        });

        // Accessory Names
        const accNames = ["NONE", "SCARF", "BACKPACK", "FLOWER"];
        document.getElementById('acc-next').addEventListener('click', () => {
            Game.player.accessoryStyle = (Game.player.accessoryStyle + 1) % accNames.length;
            document.getElementById('acc-display').innerText = accNames[Game.player.accessoryStyle];
            Game.previewCustomization();
        });
        document.getElementById('acc-prev').addEventListener('click', () => {
            Game.player.accessoryStyle = (Game.player.accessoryStyle - 1 + accNames.length) % accNames.length;
            document.getElementById('acc-display').innerText = accNames[Game.player.accessoryStyle];
            Game.previewCustomization();
        });

        // Height
        document.getElementById('height-next').addEventListener('click', () => {
            if (Game.player.heightScale < 1.3) Game.player.heightScale += 0.05;
            document.getElementById('height-display').innerText = Math.round(Game.player.heightScale * 100) + "%";
            Game.previewCustomization();
        });
        document.getElementById('height-prev').addEventListener('click', () => {
            if (Game.player.heightScale > 0.7) Game.player.heightScale -= 0.05;
            document.getElementById('height-display').innerText = Math.round(Game.player.heightScale * 100) + "%";
            Game.previewCustomization();
        });
        
        // Sword Customization
        const swordNames = ["NAIL", "NEEDLE", "GREATSWORD", "SCYTHE", "BLASTER"];
        document.getElementById('sword-next').addEventListener('click', () => {
            Game.player.swordStyle = (Game.player.swordStyle + 1) % swordNames.length;
            document.getElementById('sword-display').innerText = swordNames[Game.player.swordStyle];
            Game.previewCustomization();
        });
        document.getElementById('sword-prev').addEventListener('click', () => {
            Game.player.swordStyle = (Game.player.swordStyle - 1 + swordNames.length) % swordNames.length;
            document.getElementById('sword-display').innerText = swordNames[Game.player.swordStyle];
            Game.previewCustomization();
        });

        // Background Upload
        document.getElementById('bg-upload').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if(file) {
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.onload = () => {
                        Game.customBg = img;
                        console.log("Custom BG Loaded");
                    };
                    img.src = evt.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        // Chat Button
        document.getElementById('chat-send-btn').addEventListener('click', Game.sendChat);

        Game.enemies.push(new Enemy(500, 470));
        Game.enemies.push(new Enemy(700, 270));
        Game.enemies.push(new Enemy(-300, 470));
        Game.enemies.push(new Enemy(0, -530));
    },
    
    previewCustomization: () => {
        const c = document.getElementById('preview-canvas');
        const ctx = c.getContext('2d');
        ctx.clearRect(0,0,120,120);
        
        // Adjust preview centering based on height
        const h = 40 * Game.player.heightScale;
        const y = 60 + (20 - h/2); 
        
        drawVessel(ctx, 60 - 12, y, 24, 40, 1, 1, 1, true, false, false, null, 
            Game.player.cloakColor, 
            Game.player.maskStyle, 
            Game.player.swordStyle,
            Game.player.outfitStyle,
            Game.player.heightScale,
            Game.player.accessoryStyle
        );
    },

    startGame: () => {
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('hud').classList.remove('hidden');
        Game.running = true;
        requestAnimationFrame(Game.loop);
    },
    
    resumeGame: () => {
        document.getElementById('pause-menu').classList.add('hidden');
        Game.running = true;
        requestAnimationFrame(Game.loop);
    },
    
    saveGame: () => {
        const notif = document.getElementById('notification');
        notif.style.opacity = 1;
        setTimeout(() => notif.style.opacity = 0, 2000);
    },
    
    toggleChat: (show) => {
        const chat = document.getElementById('chat-container');
        const input = document.getElementById('chat-input');
        
        if (show) {
            chat.style.display = 'block';
            input.value = '';
            input.focus();
            Input.active = false;
            Input.reset();
        } else {
            chat.style.display = 'none';
            Input.active = true;
            Game.canvas.focus();
        }
    },
    
    sendChat: () => {
        const input = document.getElementById('chat-input');
        const msg = input.value.trim().substring(0, 30);
        if (msg) {
            Game.player.chatMessage = msg;
            Game.player.chatTimer = 300; // 5 seconds
        }
        Game.toggleChat(false);
    },
    
    resize: () => {
        Game.canvas.width = window.innerWidth;
        Game.canvas.height = window.innerHeight;
    },
    
    sceneTransition: () => {
        const curtain = document.createElement('div');
        curtain.style.cssText = `position:fixed;top:0;left:0;width:100%;height:100%;background:black;transition:opacity 0.5s;z-index:999;`;
        document.body.appendChild(curtain);
        setTimeout(() => curtain.style.opacity = 0, 100);
        setTimeout(() => curtain.remove(), 600);
    },
    
    updateHUD: () => {
        const hpBar = document.getElementById('health-bar');
        hpBar.innerHTML = '';
        for(let i=0; i<Game.player.maxHealth; i++) {
            const d = document.createElement('div');
            d.className = 'mask' + (i >= Game.player.health ? ' broken' : '');
            hpBar.appendChild(d);
        }
        const soulPct = (Game.player.soul / Game.player.maxSoul) * 100;
        document.getElementById('soul-meter').style.height = soulPct + '%';
    },

    drawBackground: (ctx, cx, cy) => {
        if (Game.customBg) {
            // Draw Custom Image Cover
            ctx.drawImage(Game.customBg, 0, 0, Game.canvas.width, Game.canvas.height);
            return;
        }

        // Simple Parallax
        const bgY = cy * 0.2;
        const bgX = cx * 0.2;
        
        // Deep Background
        ctx.fillStyle = '#050510';
        ctx.fillRect(0, 0, Game.canvas.width, Game.canvas.height);

        // Pillars
        ctx.fillStyle = '#0a0a1a';
        for(let i=-2; i<5; i++) {
            ctx.fillRect((i*400) - (bgX%400), 0, 50, Game.canvas.height);
        }

        // Midground (Silhouettes)
        ctx.fillStyle = '#111122';
        for(let i=-5; i<20; i++) {
             ctx.beginPath();
             ctx.moveTo(i*200 - (cx*0.5), 1000 - (cy*0.5));
             ctx.lineTo(i*200 + 100 - (cx*0.5), 200 - (cy*0.5)); // Spikes/Mts
             ctx.lineTo(i*200 + 200 - (cx*0.5), 1000 - (cy*0.5));
             ctx.fill();
        }
    },

    loop: () => {
        if (!Game.running) return;
        if (Input.pause()) {
            Game.running = false;
            document.getElementById('pause-menu').classList.remove('hidden');
            return;
        }

        const ctx = Game.ctx;
        
        Game.player.update(Game.map, Game.enemies);
        Game.enemies.forEach(e => e.update(Game.map, Game.player));
        
        Game.fireballs.forEach((f, i) => {
            f.update(Game.map, Game.enemies);
            if(f.markedForDeletion) Game.fireballs.splice(i, 1);
        });

        Game.particles.forEach((p, i) => {
            p.update();
            if(p.markedForDeletion) Game.particles.splice(i, 1);
        });

        if (window.Network && window.Network.connected) {
            window.Network.sendUpdate(Game.player);
        }

        let targetCamX = Game.player.x + Game.player.w/2 - Game.canvas.width/2;
        let targetCamY = Game.player.y + Game.player.h/2 - Game.canvas.height/2;
        
        Game.camera.x += (targetCamX - Game.camera.x) * 0.1;
        Game.camera.y += (targetCamY - Game.camera.y) * 0.1;
        
        let shakeX = 0, shakeY = 0;
        if (Game.camera.shake > 0) {
            shakeX = (Math.random() - 0.5) * Game.camera.shake;
            shakeY = (Math.random() - 0.5) * Game.camera.shake;
            Game.camera.shake *= 0.9;
            if(Game.camera.shake < 0.5) Game.camera.shake = 0;
        }

        const cx = Game.camera.x + shakeX;
        const cy = Game.camera.y + shakeY;

        // Draw World
        Game.drawBackground(ctx, cx, cy);

        ctx.fillStyle = COLORS.platform;
        ctx.strokeStyle = COLORS.platformBorder;
        ctx.lineWidth = 2;
        for (const rect of Game.map) {
            ctx.fillRect(rect.x - cx, rect.y - cy, rect.w, rect.h);
            ctx.strokeRect(rect.x - cx, rect.y - cy, rect.w, rect.h);
        }

        // Remote Players
        if (window.Network && window.Network.remotePlayers) {
            Object.keys(window.Network.remotePlayers).forEach(key => {
                const p = window.Network.remotePlayers[key];
                const lastState = window.Network.remoteStates[key] || {};
                
                // Detect Fireball Rising Edge
                if (p.fb && !lastState.fb) {
                    if (window.Network.pvpEnabled) {
                        const fbX = (p.f || 1) === 1 ? p.x + 29 : p.x - 35;
                        Game.fireballs.push(new Fireball(fbX, p.y + 10, p.f || 1, true));
                    } else {
                        // Visual only
                        for(let i=0; i<5; i++) Game.particles.push(new Particle(p.x + 12, p.y + 20, 'rgba(200,200,255,0.8)', (p.f||1)*5, 0, 10));
                    }
                }
                
                // PvP Melee (Incoming Attack)
                if (window.Network.pvpEnabled && p.a) {
                    const swordS = p.sw || 0;
                    let reach = 40;
                    let hitH = 20;
                    if (swordS === 2) { reach = 60; hitH = 40; }
                    if (swordS === 3) { reach = 50; hitH = 30; }
                    if (swordS === 4) { reach = 100; hitH = 10; }

                    const hitX = (p.f || 1) === 1 ? p.x + 24 : p.x - reach;
                    const hitY = p.y + 10;
                    
                    if (Game.player.x < hitX + reach && Game.player.x + Game.player.w > hitX &&
                        Game.player.y < hitY + hitH && Game.player.y + Game.player.h > hitY) {
                         
                         // Check if this attack ALREADY hit us in this animation frame window? 
                         // To prevent multi-hit from same swing, we ideally need an attack ID.
                         // But for simplicity, the invulnerability frame in takeDamage handles this.
                         if (Game.player.invulnerable <= 0) {
                             Game.player.takeDamage(1, p.x, key); // Pass attacker key!
                             
                             // If I took damage and died, I should probably increment the killer's score?
                             // But I can't write to their score.
                             // Logic: If I take damage and die, I update MY 'deaths'.
                             // No, let's keep it simple. If I die, I update my score to -1? No.
                             // OK, let's use the 'Attacker' system:
                             // Since we can't sync accurately, we will just count SURVIVAL rounds?
                             // No, User wants Kill Count / Rounds.
                             // Hack: When I die, I increment my own "deaths" stat (if I had one).
                             // Then Score = Kills. Kills = ?
                             // Let's implement this: "When I hit someone, I check if they are likely to die."
                             // If their HP (which I see in snapshot) is 1, and I hit them...
                             if (p.hp <= 1) {
                                 // They are likely dead. Increment my score locally and sync it.
                                 Game.player.score++;
                                 // Add visual
                                 Game.particles.push(new Particle(p.x, p.y, 'gold', 0, -2, 40));
                             }
                         }
                    }
                }
                
                window.Network.remoteStates[key] = p;

                const msg = (p.mt && p.mt > 0) ? p.msg : null;
                drawVessel(ctx, p.x - cx, p.y - cy, 24, 40, p.f || 1, 1, 1, p.a, false, true, msg, p.cc, p.ms, p.sw, p.os, p.hs, p.as);

                ctx.fillStyle = window.Network.pvpEnabled ? '#ffaaaa' : '#aaa';
                ctx.font = '10px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(p.n || 'Vessel', p.x - cx + 12, p.y - cy - 10);
            });
        }

        Game.enemies.forEach(e => e.draw(ctx, cx, cy));

        Game.fireballs.forEach(f => f.draw(ctx, cx, cy));

        Game.player.draw(ctx, cx, cy);

        Game.particles.forEach(p => p.draw(ctx, cx, cy));

        const grad = ctx.createRadialGradient(Game.canvas.width/2, Game.canvas.height/2, 200, Game.canvas.width/2, Game.canvas.height/2, 800);
        grad.addColorStop(0, 'rgba(0,0,0,0)');
        grad.addColorStop(1, 'rgba(0,0,0,0.6)');
        ctx.fillStyle = grad;
        ctx.fillRect(0,0, Game.canvas.width, Game.canvas.height);

        requestAnimationFrame(Game.loop);
    }
};

window.Game = Game;
window.onload = Game.init;

</script>
</body>
</html>
